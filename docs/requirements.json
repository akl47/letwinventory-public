{
  "categories": [
    {
      "name": "System",
      "description": "General System"
    },
    {
      "name": "QMS",
      "description": "Quality Management System (ISO 13485:2016 §4.1, §4.2 / 21 CFR 820.20)"
    },
    {
      "name": "Design Controls",
      "description": "Design Controls (21 CFR 820.30 / ISO 13485:2016 §7.3 / AS9100D §8.3)"
    },
    {
      "name": "Purchasing Controls",
      "description": "Purchasing Controls (21 CFR 820.50 / ISO 13485:2016 §7.4 / AS9100D §8.4)"
    },
    {
      "name": "Identification & Traceability",
      "description": "Identification and Traceability (21 CFR 820.60, 820.65 / ISO 13485:2016 §7.5.3, §7.5.9 / AS9100D §8.5.2)"
    },
    {
      "name": "Production & Process Controls",
      "description": "Production and Process Controls (21 CFR 820.70 / ISO 13485:2016 §7.5 / AS9100D §8.5)"
    },
    {
      "name": "Labeling Controls",
      "description": "Labeling Controls (21 CFR 820.120 / ISO 13485:2016 §7.5.1 / AS9100D §8.5.1)"
    },
    {
      "name": "Records & Data Integrity",
      "description": "Records and Data Integrity (21 CFR 820.180-186 / ISO 13485:2016 §4.2.5)"
    },
    {
      "name": "Operational Risk Management",
      "description": "Operational Risk Management (AS9100D §8.1.1)"
    },
    {
      "name": "Configuration Management",
      "description": "Configuration Management (AS9100D §8.1.2)"
    },
    {
      "name": "Product Safety",
      "description": "Product Safety (AS9100D §8.1.3)"
    },
    {
      "name": "Counterfeit Parts Prevention",
      "description": "Prevention of Counterfeit Parts (AS9100D §8.1.4)"
    },
    {
      "name": "External Providers",
      "description": "Control of Externally Provided Products (AS9100D §8.4 / ISO 13485:2016 §7.4)"
    },
    {
      "name": "Production Process Verification",
      "description": "Production Process Verification (AS9100D §8.5.1.3)"
    },
    {
      "name": "Nonconforming Product",
      "description": "Nonconforming Product Control (AS9100D §8.7 / 21 CFR 820.90 / ISO 13485:2016 §8.3)"
    },
    {
      "name": "Authentication",
      "description": "Authentication & Authorization"
    },
    {
      "name": "Inventory",
      "description": "Inventory Management"
    },
    {
      "name": "Barcode",
      "description": "Barcode Management"
    },
    {
      "name": "Parts",
      "description": "Parts Management"
    },
    {
      "name": "Orders",
      "description": "Order Management"
    },
    {
      "name": "Wire Harness",
      "description": "Wire Harness Design"
    },
    {
      "name": "Planning",
      "description": "Planning & Task Management"
    },
    {
      "name": "File Management",
      "description": "File Management"
    },
    {
      "name": "Mobile",
      "description": "Mobile Scanner"
    },
    {
      "name": "Configuration",
      "description": "Configuration & Printer Management"
    },
    {
      "name": "UX",
      "description": "UI/UX Requirements"
    },
    {
      "name": "Notifications",
      "description": "Push Notifications"
    },
    {
      "name": "Design Requirements",
      "description": "Design Requirements"
    },
    {
      "name": "Development",
      "description": "Development Requirements"
    }
  ],
  "requirements": [
    {
      "description": "The system shall provide a web-based enterprise resource application.",
      "rationale": "Centralized management of manufacturing workflow from procurement through assembly.",
      "parameter": "Web application accessible via modern browsers (Chrome, Firefox, Edge, Safari).",
      "verification": "All derived requirement verification criteria pass.",
      "validation": "User can log in and access all major functional areas.",
      "categoryName": "System",
      "children": [
        {
          "description": "The system shall use soft deletion for all user-created data by setting `activeFlag = false` rather than removing records.",
          "rationale": "Preserves audit trail and enables data recovery per 21 CFR 820.184 (device history record) and ISO 13485:2016 §4.2.5 (control of records). Prevents accidental permanent data loss.",
          "parameter": "All models with `activeFlag` field (BOOLEAN, default: true). Queries filter by `activeFlag: true` unless explicitly including inactive.",
          "verification": "DELETE endpoints set activeFlag=false. Record remains in database after deletion. Backend tests verify soft delete behavior.",
          "validation": "Deleted items disappear from default views but can be recovered or shown via \"Show Inactive\" toggles.",
          "categoryName": "System"
        },
        {
          "description": "The system shall authenticate users via Google OAuth 2.0.",
          "rationale": "Leverages existing Google accounts for SSO. No custom password management required.",
          "parameter": "Google OAuth with `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET`. Callback URL configurable per environment. Passport.js GoogleStrategy.",
          "verification": "`GET /api/auth/google` redirects to Google OAuth consent screen. `GET /api/auth/google/callback` processes OAuth token.",
          "validation": "User can click \"Login with Google\", authenticate, and be redirected back to the application.",
          "categoryName": "Authentication",
          "children": [
            {
              "description": "The system shall issue JWT access tokens upon successful authentication.",
              "rationale": "Stateless authentication for API requests. Token contains user identity.",
              "parameter": "JWT signed with `JWT_SECRET`. Payload: `{ id, displayName, email }`. Token sent in `Authorization: Bearer <token>` header.",
              "verification": "`GET /api/auth/user/checkToken` returns 200 for valid token, 401 for invalid/expired. Backend test: `auth.test.js` checkToken tests.",
              "validation": "Authenticated requests succeed. Unauthenticated requests return 401.",
              "categoryName": "Authentication"
            },
            {
              "description": "The system shall support JWT token refresh using httpOnly refresh tokens stored as cookies.",
              "rationale": "Extends session duration without requiring re-login. httpOnly cookie prevents XSS theft.",
              "parameter": "Refresh token: 64-char random string stored in `RefreshTokens` table. Sent as httpOnly cookie. `POST /api/auth/user/refresh` exchanges refresh token for new access token.",
              "verification": "`POST /api/auth/user/refresh` returns new accessToken. Backend test: `auth.test.js` refresh token test.",
              "validation": "When access token expires, frontend interceptor automatically refreshes and retries the failed request.",
              "categoryName": "Authentication",
              "children": [
                {
                  "description": "The frontend shall automatically retry failed requests after token refresh on 401 responses.",
                  "rationale": "Seamless user experience when tokens expire during active session.",
                  "parameter": "`authInterceptor` catches 401, calls refresh endpoint, queues concurrent requests, retries all after refresh succeeds. 403 responses clear token and redirect to home.",
                  "verification": "Unit test: interceptor retries request after successful refresh. Frontend test: `auth.interceptor.spec.ts` lines 37–192 (add auth header, skip for refresh endpoint, 401 token refresh retry, redirect on null/error refresh, request queuing during active refresh, 403 clear token + redirect, non-401/403 passthrough).",
                  "validation": "User does not see login prompt during normal usage when refresh token is valid.",
                  "categoryName": "Authentication"
                }
              ]
            },
            {
              "description": "The system shall protect all API endpoints (except auth) with token authentication middleware.",
              "rationale": "Prevents unauthorized access to application data.",
              "parameter": "`checkToken` middleware on all non-auth routes. Validates JWT, loads user from database, verifies `activeFlag: true`. Sets `req.user` with user data.",
              "verification": "Requests without Authorization header return 401. Requests with invalid token return 401. Backend tests verify 401 for unauthenticated requests.",
              "validation": "All protected pages redirect to login when not authenticated.",
              "categoryName": "Authentication"
            },
            {
              "description": "The system shall allow users to view and update their profile information.",
              "rationale": "Users may need to update display preferences.",
              "parameter": "`GET /api/auth/user` returns user profile. `PUT /api/auth/user` updates user fields.",
              "verification": "Backend test: `auth.test.js` getUser and updateUser tests.",
              "validation": "User can see their name and email. User can update display name.",
              "categoryName": "Authentication"
            },
            {
              "description": "The system shall support a Google Add-on token exchange for calendar integration.",
              "rationale": "Enables Google Workspace Add-on to authenticate against the API.",
              "parameter": "`POST /api/auth/addon/token` accepts Google ID token, verifies with Google, returns Letwinventory JWT.",
              "verification": "Endpoint accepts valid Google ID token and returns JWT.",
              "validation": "Google Add-on can authenticate and create task time tracking entries.",
              "categoryName": "Authentication"
            },
            {
              "description": "The frontend shall provide an auth guard that redirects unauthenticated users to the login page.",
              "rationale": "Prevents access to protected routes without valid session.",
              "parameter": "`authGuard` checks `AuthService.isAuthenticated()` signal. On page refresh, calls `checkAuthStatus()`. Redirects to `/home` if not authenticated.",
              "verification": "Unit test: guard returns false and navigates to /home when not authenticated. Frontend test: `auth.guard.spec.ts` lines 22–48 (allow when authenticated, check auth status, redirect on failure).",
              "validation": "Manually navigating to a protected URL without login redirects to home page.",
              "categoryName": "Authentication"
            }
          ]
        },
        {
          "description": "The system shall provide a hierarchical inventory structure of Locations, Boxes, Traces (parts), and Equipment, each identified by a unique barcode.",
          "rationale": "Physical warehouse organization requires nested container structure with barcode tracking.",
          "parameter": "Hierarchy: Locations contain Boxes/Traces/Equipment. Each entity has a `barcodeID` linking to a unique Barcode record. Parent-child relationships via `parentBarcodeID`.",
          "verification": "Backend tests verify Location, Box, Trace, Equipment CRUD operations. Frontend test: `inventory-higherarchy-view.spec.ts` lines 56–178 (tree building from flat tags, nested children, deep nesting, search by name/barcode, equipment filter toggle, barcode selection).",
          "validation": "User can navigate the inventory tree view, expanding locations to see contained items.",
          "categoryName": "Inventory",
          "children": [
            {
              "description": "The system shall display inventory in a tree view with expand/collapse navigation.",
              "rationale": "Intuitive visualization of physical warehouse layout.",
              "parameter": "Frontend `InventoryHierarchyView` component. Recursive `InventoryHierarchyItem` nodes. Backend `GET /api/inventory/location/higherarchy` returns tree data. Search filters by name/barcode/part number. Toggle to show/hide equipment. Deep linking via `?barcode=<id>` auto-expands path.",
              "verification": "Backend test: location hierarchy endpoint returns tree structure (PostgreSQL-specific, requires integration test). Frontend test: `inventory-higherarchy-view.spec.ts` lines 60–112 (tree building, child nesting, deep nesting, search filtering, barcode search), `inventory-higherarchy-item.spec.ts` (toggle expand, dialog integrations, child event propagation).",
              "validation": "User can expand locations, see nested boxes and parts, search for items, and click to view details.",
              "categoryName": "Inventory"
            },
            {
              "description": "The system shall support CRUD operations for Locations.",
              "rationale": "Users need to create and manage physical storage locations.",
              "parameter": "Location model: name (STRING 16), description (STRING 62), barcodeID (FK, unique). Create auto-generates barcode with LOC prefix. Body validator enforces field types. `GET /:id`, `POST /`, `PUT /:id` endpoints.",
              "verification": "Backend tests: `location.test.js` - get by ID, update location.",
              "validation": "User can create a new location in the inventory dialog and see it in the tree.",
              "categoryName": "Inventory"
            },
            {
              "description": "The system shall support CRUD operations for Boxes.",
              "rationale": "Boxes are containers within locations for organizing smaller items.",
              "parameter": "Box model: name (STRING 16), description (STRING 62), barcodeID (FK, unique). Create auto-generates barcode with BOX prefix. Body validator enforces field types. `GET /:id`, `POST /`, `PUT /:id` endpoints.",
              "verification": "Backend tests: `box.test.js` - get by ID, update box.",
              "validation": "User can create a box within a location and see it nested in the tree.",
              "categoryName": "Inventory"
            },
            {
              "description": "The system shall support CRUD operations for Traces (inventory items with quantity tracking).",
              "rationale": "Traces represent physical stock of parts with quantities, serial numbers, and lot numbers.",
              "parameter": "Trace model: partID (FK, not null), quantity (FLOAT, not null), unitOfMeasureID (FK), serialNumber (STRING), lotNumber (STRING), barcodeID (FK, unique). Create auto-generates barcode with AKL prefix. Supports split (divide quantity), merge (combine two traces of same part), and partial deletion.",
              "verification": "Backend tests: `trace.test.js` - get by part ID, get by ID, update, delete by barcode.",
              "validation": "User can see part quantities in the tree, split a trace, merge traces, and delete inventory.",
              "categoryName": "Inventory",
              "children": [
                {
                  "description": "The system shall allow splitting a trace into two separate traces.",
                  "rationale": "Enables dividing inventory when moving partial quantities to different locations.",
                  "parameter": "`POST /api/inventory/trace/split/:barcodeId` with `{ splitQuantity }`. Creates new barcode and trace with split quantity. Reduces source trace quantity. Records SPLIT action in barcode history.",
                  "verification": "Backend test: split trace (PostgreSQL-specific due to barcode generation).",
                  "validation": "User can split a trace and see two separate items with correct quantities.",
                  "categoryName": "Inventory"
                },
                {
                  "description": "The system shall allow merging two traces of the same part.",
                  "rationale": "Consolidates inventory when combining stock from different locations.",
                  "parameter": "`POST /api/inventory/trace/merge/:barcodeId` with `{ mergeBarcodeId }`. Adds source quantity to target. Deactivates source trace and barcode. Validates same partID. Records MERGED action in barcode history.",
                  "verification": "Test: merge endpoint combines quantities and deactivates source.",
                  "validation": "User can merge two traces of the same part into one.",
                  "categoryName": "Inventory"
                },
                {
                  "description": "The system shall allow partial or full deletion of trace inventory.",
                  "rationale": "Accounts for consumed, damaged, or lost inventory.",
                  "parameter": "`DELETE /api/inventory/trace/barcode/:barcodeId` with optional `{ deleteQuantity }`. If deleteQuantity provided: reduces quantity (must be less than current). If null: full deletion (deactivates trace and barcode). Records DELETED action in barcode history.",
                  "verification": "Backend test: delete trace by barcode.",
                  "validation": "User can reduce or fully remove inventory from the system.",
                  "categoryName": "Inventory"
                }
              ]
            },
            {
              "description": "The system shall support CRUD operations for Equipment with serial number and commission date tracking.",
              "rationale": "Equipment requires individual tracking beyond simple quantity counts.",
              "parameter": "Equipment model: name (STRING, not null), description, serialNumber, commissionDate (DATEONLY), barcodeID (FK, unique), partID (FK), orderItemID (FK). `GET /`, `GET /:id`, `POST /`, `POST /receive`, `PUT /:id`, `DELETE /:id` endpoints. Receive endpoint creates equipment from order item with barcode history.",
              "verification": "Backend tests: `equipment.test.js` - list, get by ID, update, delete. Frontend test: `equipment-table-view.spec.ts` (loading, filtering, pagination, sorting, dialog integration), `equipment-edit-dialog.spec.ts` (create/edit modes, validation, delete confirmation).",
              "validation": "User can create equipment, assign serial numbers, track commission dates, and link to parts/orders.",
              "categoryName": "Inventory"
            },
            {
              "description": "The system shall maintain reference data for Units of Measure.",
              "rationale": "Parts can be measured in different units (each, grams, gallons, etc.).",
              "parameter": "Seeded values: ea (Each), gal (Gallon), g (Gram), kg (Kilogram). `GET /api/inventory/unitofmeasure` returns all active UoMs.",
              "verification": "Backend test: `unitOfMeasure.test.js` - list returns seeded values.",
              "validation": "UoM dropdown in part/trace forms shows available units.",
              "categoryName": "Inventory"
            },
            {
              "description": "The system shall auto-generate unique barcode strings in the format PREFIX-XXXXXX (hex) for each new barcode-tracked entity.",
              "rationale": "Unique machine-readable identifiers for all physical items.",
              "parameter": "Barcode model: barcode (STRING, unique), barcodeCategoryID (FK), parentBarcodeID (INT). Categories: AKL (parts/traces), LOC (locations), BOX (boxes), EQP (equipment). Barcode generation via PostgreSQL sequence in `beforeValidate` hook.",
              "verification": "Backend tests: `barcode.test.js` - list barcodes, categories, location barcodes, lookup by string.",
              "validation": "Each new location/box/trace/equipment receives a unique barcode string.",
              "categoryName": "Barcode",
              "children": [
                {
                  "description": "The system shall support barcode lookup by barcode string.",
                  "rationale": "Scanning a barcode needs to resolve to the associated item.",
                  "parameter": "`GET /api/inventory/barcode/lookup/:barcode` returns barcode with category. Returns 404 for nonexistent barcode.",
                  "verification": "Backend test: lookup returns barcode data, 404 for nonexistent.",
                  "validation": "Scanning or entering a barcode string retrieves the correct item.",
                  "categoryName": "Barcode"
                },
                {
                  "description": "The system shall support moving barcodes between parent locations.",
                  "rationale": "Items are physically moved between locations in the warehouse.",
                  "parameter": "`POST /api/inventory/barcode/move/:id` with `{ newLocationID }`. Validates barcode exists, prevents self-move. Updates `parentBarcodeID`. Records MOVED action in barcode history with from/to IDs.",
                  "verification": "Backend test: move barcode (PostgreSQL-specific raw SQL). Frontend test: `barcode-movement-dialog.spec.ts` lines 44–122 (move action: canSubmit requires destination, executeMove API call, self-move prevention, close on success, error handling for lookup 404 and move failure).",
                  "validation": "User can move an item to a different location and see it in the new location's tree.",
                  "categoryName": "Barcode"
                },
                {
                  "description": "The system shall maintain a complete history of barcode actions.",
                  "rationale": "Audit trail for inventory movement, receipt, split, merge, and deletion.",
                  "parameter": "BarcodeHistory model: barcodeID, userID, actionID (FK to action type), fromID, toID, serialNumber, lotNumber, qty, unitOfMeasureID. Action types: CREATED, MOVED, RECEIVED, SPLIT, MERGED, DELETED. `GET /api/inventory/barcodehistory`, `GET /actiontypes`, `GET /barcode/:barcodeId`.",
                  "verification": "Backend tests: `barcodeHistory.test.js` - list all, action types, by barcode. Frontend test: `barcode-history.spec.ts` lines 84–365 (route param loading, barcode map building, column switching for trace/non-trace, date sorting, search by action/user/barcode, action labels and icons, barcode string resolution, action dialog handlers).",
                  "validation": "User can view the full movement/action history timeline for any barcode.",
                  "categoryName": "Barcode"
                },
                {
                  "description": "The system shall generate ZPL label code for barcode printing in 3x1 and 1.5x1 inch label sizes.",
                  "rationale": "Physical barcode labels needed for warehouse items. Multiple label sizes for different use cases.",
                  "parameter": "`GET /api/inventory/barcode/display/:id?labelSize=3x1` returns ZPL string. Includes QR code, company branding, item name, description, and quantity (for traces). Two label sizes: 3\"x1\" (default) and 1.5\"x1\". Frontend previews via Labelary API rendering.",
                  "verification": "Endpoint returns valid ZPL string for each barcode type (LOC, BOX, AKL, EQP). Frontend test: `barcode-dialog.spec.ts` lines 54–239 (initialization with barcode data, ZPL fetch, image rendering, preview size change re-fetch, print options toggle, label size toggle, print error handling, move and history navigation).",
                  "validation": "User can preview barcode labels in the dialog and they render correctly at both sizes.",
                  "categoryName": "Barcode",
                  "children": [
                    {
                      "description": "The barcode dialog shall support independent preview and print size selection.",
                      "rationale": "Users may want to preview at one size but print at another.",
                      "parameter": "Separate \"Preview Size\" and \"Print Label Size\" dropdowns. Preview updates dynamically on size change (re-fetches ZPL and renders via Labelary API). Print options collapsible: hidden by default, shown on \"Print Label\" click, two-step confirmation workflow.",
                      "verification": "Preview re-renders when size changed. Print sends correct size to API. Frontend test: `barcode-dialog.spec.ts` lines 108–181 (default preview/label sizes, onPreviewSizeChange re-fetches ZPL, no-op without barcodeId, togglePrintOptions, onLabelSizeToggle for 3x1/1.5x1), lines 182–239 (printLabel error guard, printBarcode service call, print error handling).",
                      "validation": "User selects 1.5x1 preview, sees small label. Selects 3x1 for print, prints large label.",
                      "categoryName": "UX"
                    }
                  ]
                },
                {
                  "description": "The system shall support printing barcodes to Zebra label printers via direct TCP or WebSocket print agent.",
                  "rationale": "Automated label printing reduces manual label creation.",
                  "parameter": "`POST /api/inventory/barcode/print/:id` with `{ labelSize, printerIP }`. Printer selection: 3x1 → 10.50.20.91, 1.5x1 → 10.50.20.92, or custom IP. Prefers WebSocket print agent if connected, falls back to direct TCP on port 9100. Print agent authenticates with `PRINT_AGENT_API_KEY`.",
                  "verification": "Print endpoint generates ZPL and sends to printer via TCP or WebSocket.",
                  "validation": "User clicks \"Print\" in barcode dialog and physical label prints on Zebra printer.",
                  "categoryName": "Barcode",
                  "children": [
                    {
                      "description": "The system shall support a WebSocket-based print agent for remote printing.",
                      "rationale": "Enables printing when the server is not on the same network as the printer.",
                      "parameter": "WebSocket endpoint at `/ws/print-agent`. Agent authenticates with API key (10s timeout). Heartbeat every 60s (stale threshold: 2 min). Print jobs have 30s timeout. Agent reports job results (success/failure).",
                      "verification": "Print agent connects, authenticates, receives print jobs, reports results.",
                      "validation": "Labels print successfully via the print agent from a remote network.",
                      "categoryName": "Barcode"
                    },
                    {
                      "description": "The system shall support printer configuration for label printing.",
                      "rationale": "Multiple printers may be available for different label sizes.",
                      "parameter": "Printer model: name (STRING, not null), ipAddress (STRING, unique, not null), description, isDefault (BOOLEAN, default: false). `GET /api/config/printers` returns all printers.",
                      "verification": "Printers endpoint returns configured printers.",
                      "validation": "Printer selection available in barcode print dialog.",
                      "categoryName": "Configuration"
                    }
                  ]
                },
                {
                  "description": "The system shall provide a barcode tag system that resolves barcodes to their associated items with type information.",
                  "rationale": "Enables displaying human-readable information for any scanned barcode.",
                  "parameter": "`GET /api/inventory/barcode/tag/:id` returns `{ id, barcodeID, barcode, type, name, description }`. `GET /api/inventory/barcode/tag/chain/:id` returns chain of parent tags up to root. `GET /api/inventory/barcode/tag/` returns all tags across types.",
                  "verification": "Tag endpoint resolves barcode to item with correct type. Frontend test: `barcode-tag.spec.ts` (input binding, output emissions, dialog interaction).",
                  "validation": "Scanning a barcode displays the item name, type, and location chain.",
                  "categoryName": "Barcode"
                }
              ]
            }
          ]
        },
        {
          "description": "The system shall support CRUD operations for parts with categories, vendor information, and manufacturer details.",
          "rationale": "Parts catalog is the foundation of inventory — every trace and order item references a part.",
          "parameter": "Part model: name (STRING 32, unique, not null), description (STRING 62), internalPart (BOOLEAN, not null), vendor (STRING, not null), sku, link, minimumOrderQuantity (INT, not null), partCategoryID (FK, not null), serialNumberRequired, lotNumberRequired, defaultUnitOfMeasureID, manufacturer, manufacturerPN, imageFileID (FK).",
          "verification": "Backend tests: `part.test.js` - list, categories, get by ID, create, update, delete. Frontend test: `parts-table-view.spec.ts` lines 80–361 (data loading, category/type/search/inactive filtering, computed properties, pagination, sorting, navigation, color utilities, middle-click), `part-edit-page.spec.ts` (form validation, category detection, pin group management, image management), `part-edit-dialog.spec.ts` (create/edit modes, validation, image management).",
          "validation": "User can browse, create, edit, and delete parts with all fields.",
          "categoryName": "Parts",
          "children": [
            {
              "description": "The system shall require manufacturer and manufacturer part number for vendor (non-internal) parts.",
              "rationale": "Vendor parts must be traceable to their manufacturer for procurement and quality purposes.",
              "parameter": "Controller validates `!internalPart → manufacturer && manufacturerPN required`. Returns 400 if missing.",
              "verification": "Backend test: create part with internalPart=false requires manufacturer fields.",
              "validation": "Creating a vendor part without manufacturer info shows validation error.",
              "categoryName": "Parts"
            },
            {
              "description": "The system shall support part categories with color-coded tags.",
              "rationale": "Categorization helps organize and filter the parts catalog.",
              "parameter": "PartCategory model: name (STRING, unique), tagColorHex (STRING 7, default #808080). Seeded categories include at least General and one other. `GET /api/inventory/part/categories` returns all categories.",
              "verification": "Backend test: categories endpoint returns seeded values.",
              "validation": "Parts table shows colored category chips. Category filter dropdown works.",
              "categoryName": "Parts"
            },
            {
              "description": "The system shall support part image uploads and hover preview in the parts table.",
              "rationale": "Visual identification of parts speeds up inventory operations.",
              "parameter": "Part has `imageFileID` FK to UploadedFile. Frontend parts table shows image icon column. Hover shows fixed-position tooltip with image preview.",
              "verification": "Part with imageFileID returns image data in API response.",
              "validation": "User can upload an image to a part and see it in the hover preview on the parts table.",
              "categoryName": "Parts"
            },
            {
              "description": "The system shall validate part request bodies against the model schema using body validator middleware.",
              "rationale": "Prevents invalid data from reaching the database.",
              "parameter": "`bodyValidator.part` middleware on POST and PUT routes. Validates type (INTEGER, STRING, BOOLEAN) and presence of non-nullable fields. Ignores id, activeFlag, createdAt, updatedAt.",
              "verification": "Backend test: create/update with valid data succeeds, invalid data returns 400.",
              "validation": "Submitting a part form with invalid data shows appropriate error messages.",
              "categoryName": "Parts"
            },
            {
              "description": "The parts table shall support search, filtering, sorting, pagination, and URL query parameter persistence.",
              "rationale": "Large parts catalogs need efficient navigation. URL persistence enables shareable/bookmarkable views.",
              "parameter": "Search across name/description/vendor/SKU. Filter by category (multi-select), type (internal/vendor). Toggle show inactive. Sortable columns including createdAt. URL syncs: search, inactive, sort, dir, page, pageSize.",
              "verification": "Frontend test: `parts-table-view.spec.ts` lines 101–178 (search across name/vendor/category, category multi-select filter, internal/vendor type filter, inactive toggle), lines 290–321 (pagination, sorting, getTotalCount with filters).",
              "validation": "User can search, filter by category, sort by column, paginate, and share the URL.",
              "categoryName": "Parts"
            },
            {
              "description": "The part edit page shall remain on the current part after saving (not navigate away).",
              "rationale": "Users often make iterative edits and navigating away breaks the workflow.",
              "parameter": "Update success handler calls `loadPart(partId)` and exits edit mode. Creating a new part still navigates to `/parts`.",
              "verification": "After PUT request, page remains on the same part ID.",
              "validation": "User edits a part, clicks save, and remains on the same part page.",
              "categoryName": "Parts"
            }
          ]
        },
        {
          "description": "The system shall support CRUD operations for purchase orders with status workflow, line items, and vendor tracking.",
          "rationale": "Procurement workflow from order placement through receiving.",
          "parameter": "Order model: description (TEXT), vendor (STRING), trackingNumber, link, notes (TEXT), placedDate (DATE), receivedDate (DATE), orderStatusID (FK, default: 1). Status progression via `nextStatusID` self-reference on OrderStatus.",
          "verification": "Backend tests: `order.test.js` - list, statuses, line types, get by ID, create, update, delete. Frontend test: `orders-list-view.spec.ts` lines 77–315 (status loading, status toggle filtering, search, pagination, sorting, status chip classes, contrast color, item count/total price calculation, middle-click), `order-view.spec.ts` lines 78–392 (status navigation, receive mode, line item editing, pricing, date formatting, line type checks).",
          "validation": "User can create orders, track status, and manage the full procurement lifecycle.",
          "categoryName": "Orders",
          "children": [
            {
              "description": "The system shall maintain order statuses with workflow progression.",
              "rationale": "Orders progress through defined stages: Draft → Pending → Placed → Shipped → Received.",
              "parameter": "OrderStatus model: name (STRING, unique), tagColor (STRING 7), nextStatusID (FK self-reference). Seeded with at least 4 statuses. `GET /api/inventory/order/statuses` returns all.",
              "verification": "Backend test: statuses endpoint returns >= 4 statuses with Draft first.",
              "validation": "Order status chips display with correct colors. Status progression follows defined workflow.",
              "categoryName": "Orders"
            },
            {
              "description": "The system shall support order line items with quantity, price, and part linkage.",
              "rationale": "Orders contain multiple items, each referencing a part with pricing.",
              "parameter": "OrderItem model: orderID (FK, not null), partID (FK), orderLineTypeID (FK, default: 1), lineNumber (INT, default: 1), quantity (INT, default: 1), price (DECIMAL 10,5, default: 0), receivedQuantity (INT, default: 0). Body validator with POST/PUT distinction (PUT allows partial updates).",
              "verification": "Backend tests: `orderItem.test.js` - list by order, create, update, delete.",
              "validation": "User can add, edit, and remove line items from an order.",
              "categoryName": "Orders"
            },
            {
              "description": "The system shall auto-recalculate order status based on received quantities of line items.",
              "rationale": "Order status should reflect actual receiving progress.",
              "parameter": "`recalculateOrderStatus()` called on orderItem update. Checks if all items fully received → advance to next status.",
              "verification": "After updating receivedQuantity to match quantity for all items, order status advances.",
              "validation": "Receiving all items on an order automatically updates the order status.",
              "categoryName": "Orders"
            },
            {
              "description": "The system shall support bulk CSV import of orders with dry-run preview.",
              "rationale": "Large orders from vendors can be imported from spreadsheet exports rather than manual entry.",
              "parameter": "`POST /api/inventory/order/bulk-import` with `{ csvContent, vendor }`. `?dryRun=true` returns preview without creating records. CSV columns: name, vendor, qty, price. Matches existing parts by name. Creates new parts for unmatched names. Returns: partsToCreate, partsExisting, partsSkipped, orderItems, orderTotal.",
              "verification": "Backend tests: `order.test.js` - dry run preview, execute import, recognizes existing parts, 400 with no content. Frontend test: `bulk-upload.spec.ts` lines 43–290 (computed totals, dry-run preview, inline row editing with save/cancel, quantity/price parsing, remove item, status labels, price/total formatting, category helpers).",
              "validation": "User uploads CSV, sees preview with existing/new parts, confirms to create order.",
              "categoryName": "Orders"
            },
            {
              "description": "The system shall support receiving order items into inventory with barcode and location assignment.",
              "rationale": "Incoming parts need to be added to inventory with physical location tracking.",
              "parameter": "Frontend `ReceiveLineItemDialog` enables scanning barcode, selecting location, entering quantity. Creates Trace (for parts) or Equipment (for equipment items) with RECEIVED barcode history action.",
              "verification": "After receiving, Trace/Equipment record exists with correct barcode and parent location. Frontend test: `receive-line-item-dialog.spec.ts` lines 62–235 (part receiving: full/partial receipt type, receivedQuantity computation, canSubmit validation for location/quantity, submit result structure; equipment receiving: pre-fill name, quantity 1, serial number, canSubmit requires name; barcode size options).",
              "validation": "User clicks \"Receive\" on an order item, assigns location, and item appears in inventory tree.",
              "categoryName": "Orders"
            },
            {
              "description": "The orders list view shall support search, status filtering, sorting, pagination, and URL query parameter persistence.",
              "rationale": "Efficient navigation and shareable views for order management.",
              "parameter": "Search across order fields. Filter by status (multi-select). Default sort: placedDate descending. URL syncs: search, inactive, statuses (comma-separated IDs), sort, dir, page, pageSize.",
              "verification": "Frontend test: `orders-list-view.spec.ts` lines 94–167 (status selection/deselection, allStatusesSelected, someStatusesSelected, hiddenStatusCount, search with page reset, status filter with empty result), lines 177–241 (pagination, sorting, getTotalCount with filters).",
              "validation": "User can filter orders by status, search, and share the URL with filters applied.",
              "categoryName": "Orders"
            }
          ]
        },
        {
          "description": "The system shall provide a canvas-based wire harness schematic editor for designing cable assemblies.",
          "rationale": "Wire harness design requires visual placement of connectors, cables, and wiring between pins.",
          "parameter": "HTML5 Canvas 2D rendering. Elements: Connectors, Cables, Components, Sub-harnesses. Connections: Wire type (between pins) and Mating type (connector-to-connector). Data stored as JSONB `harnessData` field on WireHarness model.",
          "verification": "Backend tests: `harness.test.js` - list, get by ID, create, update, delete, next part number. Frontend test: `harness-canvas.spec.ts` lines 80–362 (inputs, outputs, zoom, addConnector/addCable/addComponent, deleteSelected guards, group/ungroup guards, export guards), `harness-page.spec.ts` lines 83–635 (initial state, computed properties, createNewHarness, tool/selection/data changes, connector/connection/pin property changes, copy/paste, undo/redo, layer ordering, element moves, export JSON, loadHarness).",
          "validation": "User can open the harness editor, place elements, draw wires, and save the design.",
          "categoryName": "Wire Harness",
          "children": [
            {
              "description": "The harness editor shall support adding, positioning, rotating, and flipping connectors.",
              "rationale": "Connectors are the primary elements in a harness design and need flexible placement.",
              "parameter": "ElectricalConnector model: label (STRING 50), type (ENUM: male/female/terminal/splice), pinCount (INT), pins (JSONB array), partID (FK). Canvas rendering with wire points (circles) and mating points (squares) on opposite sides. Rotation in 90° increments. Horizontal/vertical flip.",
              "verification": "Backend tests: `connector.test.js` - list, pin types, get by ID/part, create, update, delete. Frontend test: `harness-connector-dialog.spec.ts` lines 38–330 (create mode: form defaults, displayPart, type labels, color hex/name, isValid, clearSelectedPart, save; edit mode: form population, preserved properties; locked mode; onPartSelected with linked/unlinked parts; duplicate label detection), `harness-canvas.spec.ts` lines 198–224 (addConnector to harnessData).",
              "validation": "User can add a connector, rotate it, and see pins rendered with correct positions.",
              "categoryName": "Wire Harness"
            },
            {
              "description": "The harness editor shall support adding and editing multi-wire cables.",
              "rationale": "Cables bundle multiple wires and need visual representation.",
              "parameter": "Cable model: label (STRING 50), wireCount (INT), gaugeAWG, wires (JSONB array of {id, color, colorCode}), partID (FK). Canvas renders cable as bundle with individual wire endpoints.",
              "verification": "Backend tests: `cable.test.js` - list, get by ID/part, create, update, delete. Frontend test: `harness-add-cable-dialog.spec.ts` lines 18–310 (create mode: form defaults, displayPart, wireHex, isValid, clearSelectedPart, wire drag reorder, save; edit mode: form population, preserved IDs; duplicate label detection; onPartSelected), `harness-cable-dialog.spec.ts` (deep-cloned cables, addCable/removeCable, addWire/removeWire, quickAdd, save).",
              "validation": "User can add a cable and see individual wire endpoints for connection.",
              "categoryName": "Wire Harness"
            },
            {
              "description": "The harness editor shall support adding electrical components with pin groups.",
              "rationale": "Components like ICs, resistors need pin representation for wiring.",
              "parameter": "ElectricalComponent model: label (STRING 50), pinCount (INT), pins (JSONB array of pin groups with pins), partID (FK).",
              "verification": "Backend tests: `component.test.js` - list, get by ID/part, create, update, delete. Frontend test: `harness-component-dialog.spec.ts` lines 18–315 (create mode: form defaults, displayPart, totalPinCount, toggleGroupHidden/togglePinHidden, isValid, clearSelectedPart, save; edit mode: form population, preserved position/rotation; duplicate label detection; onPartSelected).",
              "validation": "User can add a component and wire to its pins.",
              "categoryName": "Wire Harness"
            },
            {
              "description": "The harness editor shall support drawing wire connections between element pins with orthogonal routing.",
              "rationale": "Wires must visually connect pins with clean right-angle paths.",
              "parameter": "Wire drawing mode activated by tool selection. Click start pin, click end pin to create connection. Orthogonal path calculation with lead-out direction based on element center. Obstacle avoidance. Waypoints for manual path adjustment via node edit mode. Wire properties: color, gauge, length, termination types (from WireEnd reference data).",
              "verification": "Connection data stored in harnessData.connections JSONB array. Frontend test: `harness-property-panel.spec.ts` lines 287–317 (updateConnection emission, updateConnectionInput for string/integer fields, lengthMm parsing), lines 428–477 (getEndpointDescription for connector/cable/component endpoints, getEndpointType).",
              "validation": "User can draw a wire from connector pin A to connector pin B and see an orthogonal path.",
              "categoryName": "Wire Harness"
            },
            {
              "description": "The harness editor shall support connector mating connections (direct connector-to-connector).",
              "rationale": "Mating connectors connect directly without individual wire routing.",
              "parameter": "Each connector pin has wire point (circle) and mating point (square on opposite side). Mating connections: `connectionType: 'mating'`. Backend validates mating connections are between two connectors only.",
              "verification": "Backend validation rejects mating connections to non-connector elements.",
              "validation": "User can create a mating connection between two connectors via mating points.",
              "categoryName": "Wire Harness"
            },
            {
              "description": "The harness editor shall support wire termination types from the WireEnd database.",
              "rationale": "Wire ends have specific termination types (pin, spade, ring, ferrule, etc.) that must be specified.",
              "parameter": "WireEnd model: code (STRING 20, unique), name (STRING 50), description (TEXT). Seeded: f-pin, m-pin, f-spade, m-spade, ring, fork, ferrule, soldered, bare. `GET /api/parts/wire-end`, `GET /by-code/:code`. Connection has from/to termination references.",
              "verification": "Backend tests: `wireEnd.test.js` - list, by code, by ID, create, update, delete. Frontend test: `harness-property-panel.spec.ts` lines 113–120 (loadWireEnds from service on init), lines 601–653 (getCurrentEndpointTermination from/to, updateEndpointTermination emission).",
              "validation": "Property panel shows termination type dropdowns populated from the database.",
              "categoryName": "Wire Harness"
            },
            {
              "description": "The harness editor shall support sub-harness references (nested assemblies).",
              "rationale": "Complex harnesses reuse sub-assemblies and need hierarchical composition.",
              "parameter": "SubHarnessRef stored in `harnessData.subHarnesses` JSONB. `GET /api/parts/harness/sub-harness-data?ids=1,2,3` batch fetch. `GET /:id/parents` finds parent harnesses. Canvas renders collapsed/expanded views. Backend validates: cycle detection (`wouldCreateCycle`), reference validation, delete protection (cannot delete harness used as sub-harness).",
              "verification": "Backend tests: sub-harness data fetch, parent harnesses, cycle detection in validation.",
              "validation": "User can add a sub-harness and see it rendered on the canvas with expandable view.",
              "categoryName": "Wire Harness",
              "children": [
                {
                  "description": "The harness editor shall display images and pinout diagrams for elements within sub-harnesses, with interactive expand/collapse buttons.",
                  "rationale": "Sub-harness child elements (connectors, cables, components) should display their part images just like main harness elements.",
                  "parameter": "After sub-harness data loads, images are fetched from the parts database for all child elements with a `partId`. The [+]/[-] expand buttons on sub-harness child elements are clickable to toggle image visibility. Button hit testing transforms world coordinates to sub-harness local space, then to child element local space. Toggled state is kept in the sub-harness data cache (not persisted to the parent harness).",
                  "verification": "E2E test: sub-harness elements with linked parts display images after load. Canvas renders expand buttons on sub-harness children.",
                  "validation": "User opens a harness containing a sub-harness with imaged connectors; images appear and [+] buttons toggle them.",
                  "categoryName": "Wire Harness"
                }
              ]
            },
            {
              "description": "The harness editor shall support undo/redo with maximum 50 history entries.",
              "rationale": "Design operations need to be reversible for efficient editing.",
              "parameter": "HarnessHistoryService with past/future stacks. `push(state)` for instant operations. `beginTransaction()/commitTransaction()` for drag operations. Keyboard: Ctrl+Z (undo), Ctrl+Y/Ctrl+Shift+Z (redo). Toolbar buttons disabled when stack empty.",
              "verification": "Service unit test: push/undo/redo maintain correct stack state. Frontend test: `harness-page.spec.ts` lines 433–470 (onUndo restores previous state, nothing-to-undo guard, onRedo restores next state), lines 146–155 (canUndo/canRedo computed from history service), lines 417–432 (drag start begins transaction, drag end commits transaction).",
              "validation": "User makes changes, presses Ctrl+Z to undo, Ctrl+Y to redo.",
              "categoryName": "Wire Harness"
            },
            {
              "description": "The harness editor shall auto-save changes with a 1.5-second debounce.",
              "rationale": "Prevents data loss from unsaved work while avoiding excessive API calls.",
              "parameter": "Auto-save triggers on any data change after 1.5s idle. Calls `updateHarness()` API.",
              "verification": "After data change, API call fires within debounce window.",
              "validation": "User makes a change, waits, navigates away, returns — changes are persisted.",
              "categoryName": "Wire Harness"
            },
            {
              "description": "The harness editor shall support element grouping and ungrouping via context menu.",
              "rationale": "Groups allow moving related elements together.",
              "parameter": "Context menu: \"Group Selected\" (multiple items selected), \"Ungroup\" (grouped item selected). ElementGroup stored in harnessData.groups with relative offsets.",
              "verification": "Grouping stores group data in harnessData. Ungrouping removes it.",
              "validation": "User selects multiple elements, right-clicks, groups them, then moves them together.",
              "categoryName": "Wire Harness"
            },
            {
              "description": "The harness editor canvas shall support pan, zoom, grid display, and snap-to-grid.",
              "rationale": "Navigation and alignment tools for schematic editing.",
              "parameter": "Tools: Pan (drag canvas), Zoom (scroll wheel). Grid toggle. Snap-to-grid toggle. Canvas renders grid lines when enabled.",
              "verification": "Canvas renders grid lines when enabled. Element positions snap to grid increments. Frontend test: `harness-canvas.spec.ts` lines 138–174 (default zoom, zoomIn/zoomOut, resetZoom, max/min zoom caps), lines 84–108 (default grid enabled, grid size, tool inputs).",
              "validation": "User can pan/zoom the canvas, toggle grid, and elements snap to grid positions.",
              "categoryName": "Wire Harness"
            },
            {
              "description": "The harness system shall enforce a release workflow: Draft → Review → Released.",
              "rationale": "Engineering change control requires formal review before designs are frozen.",
              "parameter": "WireHarness.releaseState: 'draft' | 'review' | 'released'. Endpoints: `POST /:id/submit-review` (draft→review, cascades to sub-harnesses), `POST /:id/reject` (review→draft, with notes), `POST /:id/release` (review→released). Released harnesses record releasedAt and releasedBy. HarnessRevisionHistory tracks all state changes with changeType and optional snapshotData.",
              "verification": "Backend tests: `harness.test.js` - submit for review, reject, release, history, revisions.",
              "validation": "User clicks \"Release\" button, harness transitions through review states, released harness locks editing.",
              "categoryName": "Wire Harness",
              "children": [
                {
                  "description": "Released harnesses shall be read-only with all editing tools disabled.",
                  "rationale": "Released designs are frozen for manufacturing use and must not be modified.",
                  "parameter": "`isReleased` signal disables: wire tool, node edit, add elements, rotate, flip, delete, undo/redo, import. Keeps enabled: select, pan, zoom, export, grid toggle. Canvas prevents dragging. Property panel disables all form fields. Selection still works for viewing properties.",
                  "verification": "All editing operations are no-ops when isReleased=true. Frontend test: `harness-page.spec.ts` lines 157–188 (isReleased computed true for released, isInReview for review, isLocked for released/review, isLocked false for draft), `harness-canvas.spec.ts` lines 101–105 (isLocked input), `harness-property-panel.spec.ts` lines 130–134 (isReleased/isLocked inputs), `harness-toolbar.spec.ts` lines 29–76 (isReleased input binding).",
                  "validation": "User cannot modify a released harness. All edit controls appear disabled.",
                  "categoryName": "Wire Harness"
                },
                {
                  "description": "The system shall create a new revision when editing a released harness.",
                  "rationale": "Design updates to released harnesses must be tracked as new revisions.",
                  "parameter": "Revisions increment alphabetically: A → B → C → ... → Z → AA → AB. \"New Revision\" button appears when harness is released. `updateHarness()` on a released harness auto-creates new revision with incremented letter, previousRevisionID link. `GET /:id/revisions` returns all revisions in family. `POST /:id/revert/:historyId` restores from snapshot.",
                  "verification": "Backend tests: revision history, all revisions, revert to snapshot.",
                  "validation": "User clicks \"New Revision\", new harness created as Rev B (or next letter), linked to previous.",
                  "categoryName": "Wire Harness"
                }
              ]
            },
            {
              "description": "The harness list view shall display release status with color-coded chips and support search, sorting, and pagination.",
              "rationale": "Users need to see design status at a glance and efficiently navigate harness designs.",
              "parameter": "Columns include releaseState with status chips: draft (gray #424242), review (orange #f57c00), released (green #388e3c). Search, sort, pagination. Default sort: updatedAt descending. URL query param persistence.",
              "verification": "Frontend test: `harness-list-view.spec.ts` lines 52–205 (initial data loading, inactive filtering, search by name/partNumber/description, sorting by name/updatedAt, pagination, getTotalCount with filters, formatDate, middle-click new tab, error handling, displayedColumns including releaseState).",
              "validation": "User sees harness list with color-coded status and can filter/sort.",
              "categoryName": "Wire Harness"
            },
            {
              "description": "The harness editor shall support import/export of harness designs as JSON.",
              "rationale": "Enables backup, sharing, and migration of harness designs.",
              "parameter": "Export: serializes harnessData to JSON file. Import: loads JSON via HarnessImportDialog, replaces current canvas data.",
              "verification": "Exported JSON can be re-imported to produce identical canvas. Frontend test: `harness-import-dialog.spec.ts` lines 39–254 (initial state, drag events, clearFile, JSON paste, validation for invalid syntax/missing name/non-array fields, backend validation success/failure/fallback, useSample, import with/without parsed data, non-JSON file rejection), `harness-page.spec.ts` lines 573–593 (onExportJSON null guard, download link creation).",
              "validation": "User exports a harness, imports it into a new harness, and sees identical design.",
              "categoryName": "Wire Harness"
            },
            {
              "description": "The harness backend shall validate harness data for structural integrity.",
              "rationale": "Prevents invalid designs from being saved.",
              "parameter": "`POST /api/parts/harness/validate` checks: sub-harness cycle detection, reference validation (all referenced IDs exist), mating connections between connectors only.",
              "verification": "Backend test: validate endpoint with valid/invalid data.",
              "validation": "Saving a harness with circular sub-harness references shows validation error.",
              "categoryName": "Wire Harness"
            },
            {
              "description": "The system shall strip base64-encoded image data from harness JSON before saving to the database and re-fetch images from the parts database on load.",
              "rationale": "Inline base64 images bloat the harnessData JSONB column. Images are already stored in the parts database (UploadedFile table) and can be re-fetched on demand.",
              "parameter": "Fields stripped before save: `connectorImage`, `pinoutDiagramImage` (connectors), `cableDiagramImage` (cables), `componentImage`, `pinoutDiagramImage` (components). On load, `syncPartsFromDatabase()` fetches images via `getConnectorByPartId`, `getCableByPartId`, `getComponentByPartId` endpoints. Image show/hide toggle flags (`showPinoutDiagram`, `showConnectorImage`, etc.) are preserved in JSON. Stripping also applies to JSON export.",
              "verification": "Backend test: saved harnessData does not contain base64 image strings. E2E test: export JSON contains no image data fields. Frontend: images display correctly after save and reload.",
              "validation": "User saves a harness with connector images, reloads the page, and images are still visible.",
              "categoryName": "Wire Harness",
              "children": [
                {
                  "description": "The system shall synchronize harness element properties from the parts database on load, detecting structural changes and silently refreshing images.",
                  "rationale": "Parts may be updated independently of harness designs. The sync ensures harness elements reflect current part definitions.",
                  "parameter": "On harness load, for each connector/cable/component with a `partId`, the system fetches the current part record. Structural changes (type, pinCount, color, pins, gaugeAWG, wireCount, wires, pinGroups) are presented to the user in a sync dialog for acceptance/rejection. Image data is always refreshed silently. The `by-part` backend endpoints include nested `Part.imageFile` association for fallback image resolution.",
                  "verification": "Backend test: `getConnectorByPartId`, `getCableByPartId`, `getComponentByPartId` include `Part.imageFile` in response. Frontend test: `harness-sync-dialog.spec.ts` lines 69–145 (receive changes from data, getTypeIcon for connector/cable/component/unknown, acceptSelected closes with current state and preserves accepted flags, keepAll sets all to not accepted, empty changes handling).",
                  "validation": "User updates a connector's pin count in the parts library, opens a harness using that connector, and sees a sync prompt with the change.",
                  "categoryName": "Wire Harness"
                }
              ]
            },
            {
              "description": "The harness editor shall support keyboard shortcuts for common operations.",
              "rationale": "Power users need fast access to editing tools.",
              "parameter": "V: select tool, H: pan tool, C: copy, V (with Ctrl): paste, Delete: delete selected, Arrow keys: nudge selected, Ctrl+Z: undo, Ctrl+Y/Ctrl+Shift+Z: redo.",
              "verification": "Key press activates correct tool or operation. Frontend test: `harness-toolbar.spec.ts` lines 77–108 (setTool emits toolChanged for select/pan/nodeEdit/connector tools), `harness-page.spec.ts` lines 236–254 (onToolChanged/onCanvasToolChangeRequest updates active tool).",
              "validation": "User presses V to switch to select, H to pan, Ctrl+Z to undo.",
              "categoryName": "UX"
            }
          ]
        },
        {
          "description": "The system shall provide a Kanban-style task board with drag-and-drop between columns.",
          "rationale": "Visual task management with column-based workflow (e.g., Backlog → In Progress → Done).",
          "parameter": "TaskList model: name (STRING 20), order (INT). Task model: name (STRING 100), description (TEXT), doneFlag, dueDate, timeEstimate, taskTypeEnum (normal/tracking/critical_path/scheduled), rank (DOUBLE for ordering), parentTaskID (self-reference for subtasks). CDK DragDrop for cross-list movement.",
          "verification": "Backend tests: `task.test.js`, `taskList.test.js` - full CRUD and move operations. Frontend test: `task-list-view.spec.ts` lines 40–222 (initial state, toggleHistory, toggleEditMode with refresh, startAddingList/cancelAddingList, confirmAddList, onListRenamed/onListDeleted, filter handlers, saveAsDefault/revertToDefault, URL param parsing), `task-list.spec.ts` lines 37–181 (filtered tasks excluding done, project/noProject/childTask filtering, add/cancel task, confirmAddTask, title editing, confirmDelete, dragDelay).",
          "validation": "User sees columns with task cards, can drag cards between columns.",
          "categoryName": "Planning",
          "children": [
            {
              "description": "The system shall support task CRUD operations with project assignment, type, priority, due date, and time estimate.",
              "rationale": "Tasks need rich metadata for planning and tracking.",
              "parameter": "`POST /api/planning/task`, `GET /`, `GET /:id`, `PUT /:id`, `DELETE /:id`. Task includes: ownerUserID (from auth), projectID, taskListID, taskTypeEnum, timeEstimate, parentTaskID. Creates CREATED history entry. Auto-completes parent task when `completeWithChildren=true` and all subtasks done.",
              "verification": "Backend tests: task types, list, filter, get by ID, create (with history), update, delete. Frontend test: `task-card-dialog.spec.ts` lines 49–378 (checklist computed properties, currentListName/currentProject, filteredAvailableTasks, addChecklistItem/toggleChecklistItem/deleteChecklistItem, title editing/updating, description editing, formatEstimate/formatReminder, isDueToday/isOverdue, moveToList, selectProject, toggleSubtasks/toggleChecklist, addSubtask), `task-card.spec.ts` lines 40–279 (checklistProgress, formatEstimate, displayDone, projectColor, sortedProjects, isDueToday/isOverdue, toggleComplete with optimistic update and error revert).",
              "validation": "User can create, edit, and delete tasks with all fields populated.",
              "categoryName": "Planning",
              "children": [
                {
                  "description": "Tasks shall support an inline checklist stored as a JSONB column on the Task model.",
                  "rationale": "Lightweight checklists enable task decomposition without creating full subtask objects.",
                  "parameter": "`ChecklistItem { id: string (UUID), text: string, checked: boolean }`. Stored as `checklist` JSONB column, nullable, default null. Task card shows progress badge (`checked/total`). Task dialog provides add, toggle, delete operations with progress bar.",
                  "verification": "Backend tests: `task.test.js` checklist describe block. Frontend test: `task-card.spec.ts` lines 44–67 (checklistProgress returns progress string, null for no/empty checklist), `task-card-dialog.spec.ts` lines 53–168 (checklist computed properties, checklistProgress/checklistProgressPercent, addChecklistItem with clear draft and empty guard, toggleChecklistItem, deleteChecklistItem). E2E: `tasks.spec.ts` Task Checklist describe block.",
                  "validation": "User opens task dialog, clicks Checklist, adds items, checks/unchecks them, sees progress badge on task card.",
                  "categoryName": "Planning"
                }
              ]
            },
            {
              "description": "The system shall support moving tasks between lists with rank-based ordering.",
              "rationale": "Drag-and-drop requires flexible ordering without renumbering all tasks.",
              "parameter": "`PUT /api/planning/task/:taskId/move` with `{ taskListId, targetIndex }`. Rank calculation: between adjacent tasks, or +1000 at end. Records MOVE_LIST history action.",
              "verification": "Backend test: move task changes taskListID and rank.",
              "validation": "User drags task from one column to another, it appears in correct position.",
              "categoryName": "Planning"
            },
            {
              "description": "The system shall support task list CRUD with reordering.",
              "rationale": "Users need to create workflow columns and arrange their order.",
              "parameter": "`POST /api/planning/tasklist` auto-assigns order as (max order + 1). `PUT /reorder` with `{ orderedIds }` array. Lists include nested tasks ordered by rank.",
              "verification": "Backend tests: `taskList.test.js` - list, order, create with auto-order, update, reorder, delete.",
              "validation": "User can create new columns, drag to reorder, rename, and delete.",
              "categoryName": "Planning"
            },
            {
              "description": "The system shall support project management with color-coded tags and keyboard shortcuts.",
              "rationale": "Projects group related tasks and enable quick visual identification and assignment.",
              "parameter": "Project model: name (STRING 100), shortName (STRING 6), tagColorHex (STRING 6, stored without #), keyboardShortcut (STRING 1, unique, digits 1-9, 0 reserved for \"no project\"), parentProjectID. `GET /top` returns root projects. Colors display as chips on task cards.",
              "verification": "Backend tests: `project.test.js` - list, top-level, get by ID, create, update, delete. Frontend test: `projects-list-view.spec.ts` lines 47–179 (load projects, inactive filtering, search by name/shortName/description, sorting, pagination, goBack), `project-edit-dialog.spec.ts` lines 54–227 (create mode: form defaults, availableShortcuts excluding used, color change, form validation errors, save with # stripping; edit mode: form population, shortcut availability for current project, update/delete with confirmation).",
              "validation": "User can create projects with colors and keyboard shortcuts, see colored chips on tasks.",
              "categoryName": "Planning",
              "children": [
                {
                  "description": "The task board shall support keyboard shortcut project assignment on hover.",
                  "rationale": "Rapid project assignment without opening dialogs speeds up task triage.",
                  "parameter": "Hover over task card + press number key 1-9: assigns project with matching `keyboardShortcut`. Press 0: clears project. Toggle behavior: pressing same shortcut again removes project. Requires mouse hover (tracks `isHovered` state).",
                  "verification": "Frontend test: `task-card.spec.ts` lines 224–279 (ignore key events when not hovered, toggle complete on 'c', clear project on '0', assign project by keyboard shortcut, toggle project off when same shortcut pressed).",
                  "validation": "User hovers over task, presses \"1\", task shows project 1's color chip.",
                  "categoryName": "Planning"
                }
              ]
            },
            {
              "description": "The task board shall support filtering by projects, showing/hiding tasks without projects, and showing/hiding subtasks.",
              "rationale": "Users need to focus on specific projects or task subsets.",
              "parameter": "Sub-toolbar with project chips (multi-select), \"No Project\" filter, subtasks toggle. Filters persist as URL query params. Save as default view (cookie-based via TaskViewPreferencesService).",
              "verification": "Frontend test: `sub-toolbar.spec.ts` lines 35–202 (initial state with all projects selected, allProjectsSelected/someProjectsSelected, activeFilterCount, isProjectSelected, toggleProject, toggleAllProjects, toggleNoProject, onShowChildTasksChange, selectedProjects, navigation to /projects and /scheduled-tasks, menuExpanded, initial values from URL), `task-list.spec.ts` lines 41–74 (filter by project IDs, hide no-project tasks, hide subtasks), `task-list-view.spec.ts` lines 156–174 (onProjectFilterChanged, onShowNoProjectChanged, onShowChildTasksChanged), lines 176–201 (onSaveAsDefault, onRevertToDefault).",
              "validation": "User selects projects to filter, saves default view, reloads and sees saved filters applied.",
              "categoryName": "Planning"
            },
            {
              "description": "The system shall maintain task history for all state changes.",
              "rationale": "Audit trail for task lifecycle events.",
              "parameter": "TaskHistory model: taskID, userID, actionID (FK), fromID, toID. Action types: CREATED, ADD_TO_PROJECT, ADD_PRIORITY, CHANGE_STATUS, MOVE_LIST. `GET /api/planning/taskhistory`, `GET /actiontypes`, `GET /task/:taskId`.",
              "verification": "Backend tests: `taskHistory.test.js` - list, action types, by task. Frontend test: `history-drawer.spec.ts` lines 36–117 (isCreatedAction, getActionLabel for MOVE_LIST/ADD_TO_PROJECT/ADD_PRIORITY/CHANGE_STATUS/CREATED/unknown, getLabel for list names/projects/priorities/status, loadMoreHistory guards for loading/noMore, hasMore detection).",
              "validation": "History drawer shows timeline of task movements and changes.",
              "categoryName": "Planning"
            },
            {
              "description": "The task detail dialog shall support subtasks, calendar date picker with 15-minute rounding, and time estimates.",
              "rationale": "Detailed task management requires sub-task breakdown and scheduling.",
              "parameter": "TaskCardDialogComponent: subtask list, due date with time picker (rounds to nearest 15 minutes on open), time estimate input. Subtasks reference parentTaskID.",
              "verification": "Date picker defaults to current time rounded to 15-min interval.",
              "validation": "User opens task dialog, sets due date (pre-rounded time), adds subtasks, sets time estimate.",
              "categoryName": "Planning"
            },
            {
              "description": "The system shall support scheduled task creation from cron expressions.",
              "rationale": "Recurring tasks (maintenance, reporting) need automated creation on a schedule.",
              "parameter": "ScheduledTask model: name, description, taskListID, projectID, taskTypeEnum, timeEstimate, cronExpression (validated by cron-parser), timezone (default: America/Los_Angeles), dueDateOffsetHours, nextRunAt, lastRunAt. Backend service checks every minute, creates Task when `nextRunAt <= NOW()`, advances nextRunAt (no backfilling). `GET /?includeInactive=true` includes deactivated.",
              "verification": "Backend tests: `scheduledTask.test.js` - CRUD operations. `scheduledTaskService.test.js` - creates task, advances nextRunAt, skips inactive/future. Frontend test: `scheduled-tasks-list-view.spec.ts` lines 66–227 (data loading, inactive filtering, search by name/cron/taskList/project, sorting, pagination, cronToEnglish translation for hourly/specific time/minutes/every-minute/day-of-month/month/day-of-week/Sunday/invalid), `scheduled-task-edit-dialog.spec.ts` lines 66–257 (create mode: form defaults, timezone list, cronDescription updates, save with validation; edit mode: form population, update, delete with confirmation; ngOnDestroy unsubscribe).",
              "validation": "User creates a scheduled task with cron \"0 9 * * 1\" (Mon 9am), task appears in target list on Monday morning.",
              "categoryName": "Planning"
            },
            {
              "description": "The system shall support task time tracking linked to calendar events.",
              "rationale": "Integrates with Google Calendar Add-on for time tracking.",
              "parameter": "TaskTimeTracking model: taskID, userID, calendarEventID, calendarID. `POST /` creates entry (requires task exists). `GET /task/:taskId` and `GET /user` list entries. `DELETE /:id` with ownership validation. `DELETE /event/:calendarEventId` for calendar cleanup.",
              "verification": "Backend tests: `taskTimeTracking.test.js` - create, delete by ID, delete by event ID.",
              "validation": "Add-on creates time tracking entries visible in the application.",
              "categoryName": "Planning"
            },
            {
              "description": "The task board shall support mobile-responsive layout with snap-scroll columns and long-press drag.",
              "rationale": "Warehouse users need task management on mobile devices.",
              "parameter": "`@media (max-width: 768px)`: columns snap-scroll (`scroll-snap-type: x mandatory`), each column 100vw centered. CDK drag delay: 500ms touch (long-press), 0ms mouse. Auto-scroll during drag (48px edge zone, speed scales with proximity). Sub-toolbar collapsible on mobile. Sidebar auto-collapsed on mobile.",
              "verification": "Mobile viewport renders single column with snap-scroll. Long-press initiates drag. Frontend test: `task-list.spec.ts` lines 175–179 (dragDelay: touch 500ms, mouse 0ms).",
              "validation": "On mobile, user swipes between columns, long-presses to drag tasks.",
              "categoryName": "Planning"
            }
          ]
        },
        {
          "description": "The system shall support file upload, storage, and retrieval with base64 encoding.",
          "rationale": "Parts, connectors, and components need associated images and diagrams.",
          "parameter": "UploadedFile model: filename (STRING 255), mimeType (STRING 100), fileSize (INT), data (TEXT, base64), uploadedBy (FK to User). `GET /`, `GET /:id`, `GET /:id/data`, `POST /`, `PUT /:id`, `DELETE /:id` (soft delete).",
          "verification": "Backend tests: `files.test.js` - upload, list, get by ID, get data, update, delete.",
          "validation": "User uploads an image to a part, image displays in hover preview and edit page.",
          "categoryName": "File Management"
        },
        {
          "description": "The system shall provide a mobile camera-based barcode scanner for warehouse operations.",
          "rationale": "Hands-free scanning of physical barcodes for inventory operations in the warehouse.",
          "parameter": "Uses BarcodeDetector API (Chrome). Camera feed displayed full-screen. State machine: scanning → loading → display → action states.",
          "verification": "Component renders camera feed and detects barcodes. Frontend test: `mobile-scanner.spec.ts` lines 37–279 (initial state defaults, isTrace computed, locationChain reversal, startMove/startMerge/startSplit/startTrash state transitions, toggleTrashAll, cancelAction/cancelSecondScan/cancelSecondAction, scanAgain/tryAgain reset, goBack, getTypeBadgeClass for all types, BarcodeDetector absence handling, ngOnDestroy).",
          "validation": "User opens scanner on phone, points camera at barcode, item info displays.",
          "categoryName": "Mobile",
          "children": [
            {
              "description": "The mobile scanner shall support the Move action (scan item, scan destination).",
              "rationale": "Moving items between locations is the most common warehouse operation.",
              "parameter": "Two-scan workflow: scan source item barcode → display info → select \"Move\" → scan destination location barcode → confirm → execute move API call.",
              "verification": "After two scans and confirm, moveBarcode API is called with correct IDs. Frontend test: `mobile-scanner.spec.ts` lines 115–131 (startMove sets scanning_second state with move action), `barcode-movement-dialog.spec.ts` lines 44–122 (move action: title/icon, canSubmit requires destination, executeMove call, self-move prevention, close on success, error handling for lookup 404 and move failure).",
              "validation": "User scans a part, scans a shelf location, item moves to that location.",
              "categoryName": "Mobile"
            },
            {
              "description": "The mobile scanner shall support the Merge action (scan target, scan source).",
              "rationale": "Consolidating inventory of the same part into one location/trace.",
              "parameter": "Two-scan workflow: scan target trace → display info → select \"Merge\" → scan source trace → confirm → execute merge API call. Validates same part.",
              "verification": "After merge, target trace has combined quantity, source is deactivated. Frontend test: `mobile-scanner.spec.ts` lines 124–131 (startMerge sets scanning_second state with merge action), `barcode-movement-dialog.spec.ts` lines 123–159 (merge action: title/icon, canSubmit requires mergeBarcode, mergeTrace call, close on success).",
              "validation": "User scans two traces of the same part, merges them, one trace has combined quantity.",
              "categoryName": "Mobile"
            },
            {
              "description": "The mobile scanner shall support the Split action with quantity input.",
              "rationale": "Dividing inventory when moving partial quantities.",
              "parameter": "Single-scan workflow: scan trace → display info → select \"Split\" → enter split quantity → confirm → execute split API call.",
              "verification": "After split, original trace reduced, new trace created with split quantity. Frontend test: `mobile-scanner.spec.ts` lines 133–141 (startSplit sets confirm action and confirming_action state), `barcode-movement-dialog.spec.ts` lines 159–192 (split action: title/icon, canSubmit requires positive quantity, splitTrace call, null quantity guard).",
              "validation": "User scans a trace of 100 items, splits 25, sees two traces (75 and 25).",
              "categoryName": "Mobile"
            },
            {
              "description": "The mobile scanner shall support the Trash action with optional partial quantity.",
              "rationale": "Removing damaged or consumed inventory.",
              "parameter": "Single-scan workflow: scan trace → display info → select \"Trash\" → optionally enter quantity → confirm → execute delete API call.",
              "verification": "After trash, trace quantity reduced or trace deactivated. Frontend test: `mobile-scanner.spec.ts` lines 142–175 (startTrash sets confirm action, toggleTrashAll sets quantity to tag quantity or resets), `barcode-movement-dialog.spec.ts` lines 193–265 (delete action: title/icon for non-trace/trace-full/trace-partial, canSubmit requires confirmation matching barcode or quantity, deleteItem/deleteTrace calls).",
              "validation": "User scans a trace, trashes 5 items, trace quantity decremented by 5.",
              "categoryName": "Mobile"
            },
            {
              "description": "The mobile scanner shall include a back button for navigation.",
              "rationale": "Mobile users need to exit the scanner without using browser navigation.",
              "parameter": "Circular semi-transparent back button (arrow_back icon) in top-left corner. Uses `Location.back()`. z-index: 10, always visible over camera feed.",
              "verification": "Button renders and navigates back. Frontend test: `mobile-scanner.spec.ts` lines 226–232 (goBack calls location.back).",
              "validation": "User taps back button and returns to previous page.",
              "categoryName": "Mobile"
            }
          ]
        },
        {
          "description": "All list views shall support search, sorting, pagination, and URL query parameter persistence.",
          "rationale": "Consistent navigation patterns and shareable/bookmarkable views.",
          "parameter": "Applies to: Parts, Orders, Equipment, Harness, Projects, Scheduled Tasks. URL syncs: search, inactive, sort, dir, page, pageSize (plus view-specific params like statuses).",
          "verification": "Each list view syncs state to URL query params on change. Frontend test: `parts-table-view.spec.ts` lines 290–321 (pagination, sorting), `orders-list-view.spec.ts` lines 168–241 (search/page/sort changes), `equipment-table-view.spec.ts` (pagination, sorting), `harness-list-view.spec.ts` lines 107–144 (page reset on search, pagination), `projects-list-view.spec.ts` lines 106–128 (search resets page, pagination, sorting), `scheduled-tasks-list-view.spec.ts` lines 132–148 (search resets page, pagination).",
          "validation": "User applies filters, copies URL, opens in new tab, sees same filtered view.",
          "categoryName": "UX",
          "children": [
            {
              "description": "Table rows in list views shall support middle-click to open items in a new browser tab.",
              "rationale": "Power users need to open multiple items simultaneously for comparison or batch review.",
              "parameter": "`(auxclick)` and `(mousedown)` event handlers on table rows in parts, orders, and harness list views. Middle-click (button === 1) opens the item's edit/detail page in a new tab via `window.open()` with hash routing URL. Default middle-click scroll behavior prevented via mousedown handler.",
              "verification": "E2E test: middle-click dispatched on table row triggers `window.open`. Mousedown handler prevents default for button 1. Frontend test: `parts-table-view.spec.ts` lines 348–361 (onRowMouseDown prevents default for middle click, onRowAuxClick opens new tab), `orders-list-view.spec.ts` lines 302–315 (middle-click prevent default, open new tab), `harness-list-view.spec.ts` lines 169–195 (onRowMouseDown prevents default for middle click, onRowAuxClick opens in new tab).",
              "validation": "User middle-clicks a part row, new tab opens with the part edit page.",
              "categoryName": "UX"
            }
          ]
        },
        {
          "description": "The sidebar navigation shall be collapsible and auto-collapse on mobile devices.",
          "rationale": "Maximize content area on small screens while maintaining navigation access.",
          "parameter": "Sidebar checks `window.innerWidth <= 768` on init. Collapsed: `width: 0; min-width: 0; overflow: hidden`. Toggle button always accessible.",
          "verification": "Sidebar collapses on mobile viewport. Frontend test: `nav.component.spec.ts` lines 50–65 (toggleSidenav toggles collapsed state and toggles back).",
          "validation": "On mobile, sidebar starts collapsed. User can expand/collapse via toggle.",
          "categoryName": "UX"
        },
        {
          "description": "The system shall display error notifications using Material snackbar.",
          "rationale": "Consistent error/success feedback across the application.",
          "parameter": "ErrorNotificationService with methods for error, success, warning notifications. Auto-dismiss with configurable duration.",
          "verification": "Service displays snackbar with correct type styling.",
          "validation": "User sees snackbar notifications for API errors and successful operations.",
          "categoryName": "UX"
        },
        {
          "description": "The system shall support web push notifications via the Web Push API with VAPID authentication.",
          "rationale": "Users need real-time alerts for task due dates and scheduled task creation without keeping the app open.",
          "parameter": "VAPID keys configured per environment (`VAPID_PUBLIC_KEY`, `VAPID_PRIVATE_KEY`, `VAPID_EMAIL` in .env). Backend uses `web-push` library. Service worker (`sw.js`) handles push events and notification click navigation. PWA manifest (`manifest.webmanifest`) enables Add to Home Screen. `GET /api/config/vapid-public-key` returns public key (no auth required). `POST /api/config/test-notification` sends test push (auth required).",
          "verification": "Backend test: vapid-public-key endpoint returns key when configured, 500 when not. Push subscription CRUD endpoints function correctly. Service worker registered in browser. Frontend test: `notification.service.spec.ts` lines 24–245 (getVapidPublicKey GET, getSubscriptions GET, saveSubscription POST with toJSON payload, deleteSubscription DELETE, sendTestNotification POST, getPermissionState, subscribeToPush: denied permission, granted with save, existing subscription cleanup, null vapid key; unsubscribeFromPush: existing sub, no sub), `settings-page.spec.ts` lines 47–178 (load permission state, load subscriptions, getDeviceLabel for iOS/Android/Windows/macOS/Linux/unknown, removeDevice, sendTestNotification success/zero/failure, enableNotifications with loading state).",
          "validation": "User enables notifications in browser, receives push notification when a task is due.",
          "categoryName": "Notifications",
          "children": [
            {
              "description": "The system shall manage push notification subscriptions per user.",
              "rationale": "Each user/device combination requires a unique push subscription for targeted notifications.",
              "parameter": "PushSubscription model: userID (FK to Users, ON DELETE CASCADE), endpoint (TEXT, unique), p256dh (TEXT), auth (TEXT), userAgent (STRING 255). `POST /api/config/push-subscription` upserts by endpoint. `GET /api/config/push-subscription` lists current user's subscriptions. `DELETE /api/config/push-subscription/:id` removes subscription (ownership validated). Expired subscriptions (410 Gone) cleaned up automatically.",
              "verification": "Backend test: subscribe creates record, list returns user's subscriptions, unsubscribe removes record, 404 for wrong user's subscription. Frontend test: `notification.service.spec.ts` lines 38–85 (getSubscriptions GET, saveSubscription POST, deleteSubscription DELETE), `settings-page.spec.ts` lines 103–114 (removeDevice calls deleteSubscription and updates list).",
              "validation": "User subscribes on two devices, sees both in notification settings, removes one.",
              "categoryName": "Notifications"
            },
            {
              "description": "The system shall send push notifications for task due date reminders and scheduled task creation.",
              "rationale": "Proactive reminders prevent missed deadlines and inform users of auto-created tasks.",
              "parameter": "Notification service checks every minute for tasks with `dueDate` within reminder window where `dueDateNotifiedAt IS NULL`. After notification, sets `dueDateNotifiedAt = NOW()` to prevent duplicates. `dueDateNotifiedAt` column added to Tasks table. Scheduled task service calls `sendScheduledTaskNotification()` after creating a task. Notification payload: `{ title, body, url }`.",
              "verification": "Backend test: due date reminder finds eligible tasks and marks them notified. Scheduled task creation triggers notification call.",
              "validation": "User sets task due in 30 minutes, receives push notification at the configured reminder time.",
              "categoryName": "Notifications"
            }
          ]
        },
        {
          "description": "The system shall use a client-server architecture with an Angular frontend and Node.js/Express backend communicating via REST API.",
          "rationale": "Separation of concerns enables independent frontend/backend development and deployment.",
          "parameter": "Frontend: Angular with standalone components and signals. Backend: Express.js with Sequelize ORM. Database: PostgreSQL.",
          "verification": "Backend API responds to HTTP requests. Frontend loads and renders in browser.",
          "validation": "Application functions end-to-end across network boundary.",
          "categoryName": "Development"
        },
        {
          "description": "The system shall support environment-specific configuration for development and production deployments.",
          "rationale": "Different database hosts, OAuth callbacks, and API URLs per environment.",
          "parameter": "`.env.development` for local dev (localhost), `.env.production` for production server. `NODE_ENV` variable determines which file loads. Frontend uses Angular `fileReplacements` for environment-specific API URLs.",
          "verification": "Backend loads correct .env file based on NODE_ENV. Frontend build substitutes environment files.",
          "validation": "Application connects to correct database and API endpoints in each environment.",
          "categoryName": "Development"
        },
        {
          "description": "The system shall containerize the production deployment using Docker with automatic rebuilds on file changes.",
          "rationale": "Consistent deployment environment and developer experience.",
          "parameter": "`docker-compose.prod.yml` with backend Dockerfile. Build context at project root. Image pushed to DockerHub (`akl47/letwinventory`).",
          "verification": "Docker build succeeds. Container starts and serves application.",
          "validation": "Production deployment accessible at configured URL.",
          "categoryName": "Development",
          "children": [
            {
              "description": "The system shall deploy via GitHub Actions on version tag push.",
              "rationale": "Automated CI/CD reduces manual deployment steps and human error.",
              "parameter": "Trigger: `v*` tag push. Action: build Docker image, push to DockerHub with version and `latest` tags. Requires `DOCKERHUB_USERNAME` and `DOCKERHUB_TOKEN` secrets.",
              "verification": "GitHub Actions workflow runs on tag push. Image appears on DockerHub.",
              "validation": "New version deploys successfully via CI/CD pipeline.",
              "categoryName": "Development"
            }
          ]
        }
      ]
    },
    {
      "description": "The system shall enforce a Quality Management System (QMS) by providing documented procedures for all quality-affecting processes including design, procurement, production, traceability, and corrective actions.",
      "rationale": "21 CFR 820.20 requires each manufacturer to establish a quality system. ISO 13485:2016 §4.1 requires the organization to establish, document, implement, and maintain a QMS.",
      "parameter": "QMS scope covers: design controls (harness design), purchasing controls (orders), identification and traceability (barcodes, traces), production and process controls (task management), and records management. All quality records retained per defined retention policies.",
      "verification": "QMS documentation exists for each covered process. System enforces documented procedures via workflow constraints.",
      "validation": "Quality audit confirms all QMS processes are followed through the system.",
      "categoryName": "QMS",
      "children": [
        {
          "description": "The system shall control all quality-related documents through version-controlled, reviewable, and approvable workflows.",
          "rationale": "21 CFR 820.40 requires procedures for document controls including review, approval, distribution, and changes. ISO 13485:2016 §4.2.4 requires control of documents.",
          "parameter": "Harness designs use release workflow (Draft → Review → Released) per REQ-HAR-013. Released documents are immutable; changes create new revisions with full change history. All document changes recorded with user, timestamp, and change description.",
          "verification": "Released documents cannot be modified. All changes create new revisions. Change history is complete and unalterable.",
          "validation": "Auditor can trace any document to its complete revision history, including who approved each version.",
          "categoryName": "QMS"
        },
        {
          "description": "The system shall maintain quality records that are legible, readily identifiable, retrievable, and protected from damage, deterioration, or loss.",
          "rationale": "21 CFR 820.180 requires general record-keeping. ISO 13485:2016 §4.2.5 requires control of records. Records must be available for regulatory inspection.",
          "parameter": "All records stored in PostgreSQL with automatic timestamps (createdAt, updatedAt). Soft deletion prevents accidental loss (REQ-SYS-004). Records include: barcode history, task history, harness revision history, order history. All records include user attribution (who performed the action).",
          "verification": "All history tables include userID, timestamp, and action type. No records can be permanently deleted through the application.",
          "validation": "For any inventory item, auditor can retrieve complete history from creation through current state.",
          "categoryName": "QMS"
        },
        {
          "description": "The system shall enforce user authentication and record the identity of all personnel performing quality-affecting actions.",
          "rationale": "21 CFR 820.20(b)(1) requires defined responsibility, authority, and interrelation of personnel. ISO 13485:2016 §6.2 requires personnel competence and records. All quality records must be attributable to a specific user.",
          "parameter": "Google OAuth authentication (REQ-AUTH-001) provides unique user identity. All create, update, and delete operations record `userID` or `ownerUserID`. Barcode history records userID for all actions. Task history records userID. Harness revision history records userID and releasedBy.",
          "verification": "Every history record includes a non-null userID. All API endpoints require authentication.",
          "validation": "For any action in the system, auditor can identify which user performed it and when.",
          "categoryName": "QMS"
        },
        {
          "description": "The system shall support design and development planning, including stages, review, verification, and validation activities for wire harness designs.",
          "rationale": "21 CFR 820.30(b) requires design and development planning. ISO 13485:2016 §7.3.2 requires design and development planning with defined stages, review, verification, validation, and responsibilities.",
          "parameter": "Harness designs progress through defined lifecycle stages: Draft (active design), Review (design review), Released (design transfer). Each stage transition is recorded. Design changes after release require new revisions (REQ-HAR-015).",
          "verification": "Harness cannot transition from Draft to Released without passing through Review. All transitions recorded in history.",
          "validation": "Engineering team follows defined design stages from initial draft through release.",
          "categoryName": "Design Controls",
          "children": [
            {
              "description": "The system shall capture and maintain design inputs including component specifications, pin configurations, and wire parameters.",
              "rationale": "21 CFR 820.30(c) requires documented design inputs including performance requirements, safety requirements, and applicable standards. ISO 13485:2016 §7.3.3 requires design and development inputs.",
              "parameter": "Design inputs stored in harnessData JSONB: connectors (type, pinCount, pins), cables (wireCount, gaugeAWG, wires), components (pinCount, pin groups), wire properties (color, gauge, length, termination types). All inputs linked to parts catalog (partID references).",
              "verification": "Harness data includes all required design input fields. Parts references are valid.",
              "validation": "Design inputs are complete and sufficient to manufacture the harness.",
              "categoryName": "Design Controls"
            },
            {
              "description": "The system shall produce design outputs that can be verified against design inputs and that contain acceptance criteria.",
              "rationale": "21 CFR 820.30(d) requires design outputs in terms that allow adequate evaluation against design inputs. ISO 13485:2016 §7.3.4 requires design outputs in a form suitable for verification.",
              "parameter": "Design outputs: complete harness schematic with all connections, wire routing, and component placement. Exportable as JSON (REQ-HAR-017). Validation endpoint (REQ-HAR-018) verifies structural integrity. Released harnesses serve as manufacturing specifications.",
              "verification": "Exported design contains all information needed for manufacturing. Validation catches structural errors.",
              "validation": "Manufacturing can build a harness from the released design output without additional information.",
              "categoryName": "Design Controls"
            },
            {
              "description": "The system shall support design review at defined stages before transitioning to the next phase.",
              "rationale": "21 CFR 820.30(e) requires formal documented reviews of design results at appropriate stages. ISO 13485:2016 §7.3.5 requires design and development review.",
              "parameter": "Review gate: Draft → Review transition (submit-review endpoint). Rejection returns to Draft with notes (reject endpoint). Approval proceeds to Released (release endpoint). Review participants recorded via userID. Sub-harnesses cascade to review state.",
              "verification": "Design cannot be released without explicit review approval. Rejection notes are recorded.",
              "validation": "Design review meeting decisions are captured in the system as approve/reject with rationale.",
              "categoryName": "Design Controls"
            },
            {
              "description": "The system shall maintain a complete design change history with the ability to revert to any previous design state.",
              "rationale": "21 CFR 820.30(i) requires design changes to be identified, documented, validated, verified, reviewed, and approved before implementation. ISO 13485:2016 §7.3.9 requires control of design and development changes.",
              "parameter": "HarnessRevisionHistory model records all changes with: changeType, changedBy (userID), changedAt, notes, snapshotData (full design state). Revision letters increment (A→B→...→Z→AA). Revert endpoint restores from any snapshot. Released harness edits auto-create new revision (REQ-HAR-015).",
              "verification": "Every design change creates a history entry with before-state snapshot. Revert restores exact previous state.",
              "validation": "Auditor can view complete design evolution and revert to any prior version.",
              "categoryName": "Design Controls"
            },
            {
              "description": "The system shall provide CRUD operations for design requirements (create, read, update, soft-delete).",
              "rationale": "21 CFR 820.30 and ISO 13485:2016 §7.3 require documented design inputs, outputs, and traceability. First-class design requirement management enables regulatory compliance.",
              "parameter": "`DesignRequirements` table with fields: id, description (TEXT, required), rationale (TEXT), parameter (TEXT), verification (TEXT), validation (TEXT), ownerUserID (FK → Users), approved (BOOLEAN, default false), approvedByUserID (FK → Users), activeFlag (BOOLEAN, default true). API endpoints: `POST /api/design/requirement`, `GET /api/design/requirement`, `GET /api/design/requirement/:id`, `PUT /api/design/requirement/:id`, `DELETE /api/design/requirement/:id` (soft delete).",
              "verification": "Verified by: `backend/tests/__tests__/design/design-requirement.test.js` (POST create, GET getAll, GET getById, PUT update, DELETE soft delete, 401 without auth).",
              "validation": "User can create, view, edit, and delete design requirements through the UI.",
              "categoryName": "Design Requirements",
              "children": [
                {
                  "description": "Design requirements shall support hierarchical parent-child relationships via `parentRequirementID`.",
                  "rationale": "Requirements naturally decompose into sub-requirements; hierarchy enables traceability from high-level to detailed requirements per ISO 13485:2016 §7.3.3.",
                  "parameter": "`parentRequirementID` (INTEGER, nullable, FK → DesignRequirements.id). Self-referencing: `belongsTo` parent, `hasMany` children. GET endpoint includes parent and child associations.",
                  "verification": "Verified by: `backend/tests/__tests__/design/design-requirement.test.js` — \"Hierarchy\" describe block (creates child with parentRequirementID, GET returns parent association).",
                  "validation": "User creates parent and child requirements; tree view displays hierarchy with expand/collapse.",
                  "categoryName": "Design Requirements"
                },
                {
                  "description": "The system shall provide an approval workflow for design requirements (approve/unapprove with user tracking).",
                  "rationale": "21 CFR 820.30(c) requires design input review and approval. ISO 13485:2016 §7.3.2 requires review at suitable stages.",
                  "parameter": "`approved` (BOOLEAN, default false), `approvedByUserID` (INTEGER, nullable, FK → Users). Endpoints: `PUT /api/design/requirement/:id/approve` sets approved=true and records approver, `PUT /api/design/requirement/:id/unapprove` resets approval. Any authenticated user can approve.",
                  "verification": "Verified by: `backend/tests/__tests__/design/design-requirement.test.js` — \"Approval\" describe block (approve sets approved=true and approvedByUserID, unapprove clears both, GET includes approvedBy association, 404 for nonexistent).",
                  "validation": "User approves a requirement; approval status and approver name display in the UI.",
                  "categoryName": "Design Requirements"
                },
                {
                  "description": "The frontend shall display design requirements in a tree table with expandable/collapsible hierarchy.",
                  "rationale": "Tree view enables users to see requirement decomposition at a glance and navigate complex hierarchies.",
                  "parameter": "`mat-table` with flat data source built from hierarchical data. Rows indented by nesting level. Expand/collapse toggle for rows with children. Columns: expand toggle, description (indented), project, category, owner, approved status, actions. Project filter dropdown in toolbar.",
                  "verification": "Frontend tests verify tree building from flat array, expand/collapse state management, project filtering, navigation on row click.",
                  "validation": "User sees hierarchical requirement list, expands/collapses nodes, filters by project, clicks to navigate to edit page.",
                  "categoryName": "Design Requirements"
                },
                {
                  "description": "The system shall provide separate create and edit pages for design requirements with form validation.",
                  "rationale": "Dedicated pages allow focused requirement authoring with full validation context.",
                  "parameter": "Routes: `/requirements/new` (create mode), `/requirements/:id/edit` (edit mode with view-first pattern). Form fields: Project (required dropdown), Category (optional dropdown), Description (required textarea), Rationale, Parameter, Parent Requirement (dropdown), Verification, Validation. Edit mode shows read-only view first with Edit button. Header buttons: Back, Edit/Cancel, Save/Create, Delete, Approve/Unapprove.",
                  "verification": "Frontend tests verify create vs edit mode detection, form validation (description and project required), save/cancel/delete actions, approve/unapprove button behavior.",
                  "validation": "User creates a new requirement with required fields, edits an existing one, approves it.",
                  "categoryName": "Design Requirements"
                },
                {
                  "description": "Each design requirement must belong to a project (`projectID` FK → Projects).",
                  "rationale": "Project association enables filtering and organization of requirements per product/project, supporting ISO 13485:2016 §7.3.1 planning.",
                  "parameter": "`projectID` (INTEGER, NOT NULL, FK → Projects.id). GET endpoint supports `?projectID=` query filter. Project displayed in list view and required in create/edit form.",
                  "verification": "Verified by: `backend/tests/__tests__/design/design-requirement.test.js` — \"rejects missing projectID\", \"filters by projectID\", \"includes owner, project, and category associations\".",
                  "validation": "User selects project when creating requirement; list view filters by project.",
                  "categoryName": "Design Requirements"
                },
                {
                  "description": "The system shall support user-defined requirement categories via a `RequirementCategories` lookup table with CRUD.",
                  "rationale": "Categories enable grouping requirements by type (e.g., functional, performance, safety) for organized review.",
                  "parameter": "`RequirementCategories` table: id, name (STRING 100, NOT NULL, UNIQUE), description (TEXT), activeFlag (BOOLEAN, default true). API: `POST /api/design/requirement-category`, `GET /api/design/requirement-category`, `PUT /api/design/requirement-category/:id`, `DELETE /api/design/requirement-category/:id`. Each DesignRequirement has optional `categoryID` (FK → RequirementCategories.id). Category management via dialog from edit page.",
                  "verification": "Verified by: `backend/tests/__tests__/design/requirement-category.test.js` (POST create, duplicate name rejection, missing name rejection, GET list active, PUT update, DELETE soft delete, 401 without auth).",
                  "validation": "User creates categories via manage dialog, assigns category to requirement, sees category in list view.",
                  "categoryName": "Design Requirements"
                },
                {
                  "description": "The system shall maintain an immutable audit trail (`RequirementHistory` table) for all design requirement mutations.",
                  "rationale": "21 CFR 820.30 and ISO 13485:2016 §7.3 require traceable change history for design inputs. An immutable audit trail ensures QMS compliance with ALCOA principles.",
                  "parameter": "`RequirementHistory` table: id (PK), requirementID (FK → DesignRequirements, CASCADE), changedByUserID (FK → Users, CASCADE), changeType (STRING 20, enum: created/updated/approved/unapproved/deleted), changes (JSONB, field-level diffs as `{field: {from, to}}`), changeNotes (TEXT, nullable), createdAt (DATE). No updatedAt. Immutable — no update or delete operations.",
                  "verification": "Verified by: `backend/tests/__tests__/design/requirement-history.test.js` (table creation, association with User FK).",
                  "validation": "History records persist and cannot be modified after creation.",
                  "categoryName": "Design Requirements",
                  "children": [
                    {
                      "description": "The system shall automatically record history entries on all design requirement mutations: create, update, approve, unapprove, and delete.",
                      "rationale": "Automated recording ensures no mutation goes untracked, eliminating human error in audit trail maintenance.",
                      "parameter": "`create` logs initial field values as `{field: {from: null, to: value}}`. `update` logs field-level from/to diffs for tracked fields (description, rationale, parameter, verification, validation, parentRequirementID, projectID, categoryID); no record if nothing changed; supports optional changeNotes. `approve` logs `{approved: {from: false, to: true}, approvedByUserID: {from: null, to: id}}`. `unapprove` logs `{approved: {from: true, to: false}, approvedByUserID: {from: id, to: null}}`. `delete` logs `{activeFlag: {from: true, to: false}}`.",
                      "verification": "Verified by: `backend/tests/__tests__/design/requirement-history.test.js` (history on create, update with diffs, no record when nothing changed, changeNotes support, approve/unapprove history, delete history, full lifecycle audit trail).",
                      "validation": "User creates, edits, approves, unapproves, and deletes a requirement; each action produces a corresponding history entry.",
                      "categoryName": "Design Requirements"
                    },
                    {
                      "description": "The system shall provide a `GET /api/design/requirement/:id/history` endpoint returning all history entries ordered by createdAt DESC, including the changedBy user association.",
                      "rationale": "Enables frontend display and external audit review of requirement change history.",
                      "parameter": "Returns array of RequirementHistory entries with `changedBy` user association (id, displayName, email, photoURL). Ordered by `createdAt DESC`. Returns 404 for nonexistent requirement. Returns 401 without authentication.",
                      "verification": "Verified by: `backend/tests/__tests__/design/requirement-history.test.js` (GET returns entries DESC, includes changedBy user, 404 for missing, 401 without auth).",
                      "validation": "API returns complete, ordered history with user attribution for a given requirement.",
                      "categoryName": "Design Requirements"
                    },
                    {
                      "description": "The frontend shall display a collapsible history timeline on the requirement edit page showing change type, user, timestamp, notes, and field-level diffs.",
                      "rationale": "In-context history display enables quick review of requirement evolution without leaving the edit page.",
                      "parameter": "Collapsible section below metadata on edit page. Each entry shows: change type icon and label, user display name, timestamp, optional change notes, and field-level from/to diffs for update entries. Toggle button to show/hide history.",
                      "verification": "Frontend component includes history signal, toggle, load method, and timeline rendering.",
                      "validation": "User expands history section on edit page and sees chronological list of all changes with details.",
                      "categoryName": "Design Requirements"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "description": "The system shall establish and maintain purchasing procedures to ensure purchased products and services conform to specified requirements.",
          "rationale": "21 CFR 820.50 requires procedures for purchasing and receiving to ensure purchased products conform to specified requirements. ISO 13485:2016 §7.4.1 requires a purchasing process.",
          "parameter": "Orders include: vendor identification, part specifications (linked to parts catalog), quantities, pricing. Order status workflow tracks procurement lifecycle (Draft → Pending → Placed → Shipped → Received). Vendor parts require manufacturer and manufacturer part number (REQ-PRT-002).",
          "verification": "Orders require valid part references. Vendor parts have manufacturer traceability. Order status progression is enforced.",
          "validation": "Purchasing team can create, track, and receive orders with full vendor and part traceability.",
          "categoryName": "Purchasing Controls",
          "children": [
            {
              "description": "The system shall maintain purchasing data that clearly describes the product or service ordered including specifications, quantities, and acceptance criteria.",
              "rationale": "21 CFR 820.50(b) requires purchasing documents to include a description of the purchased product including requirements. ISO 13485:2016 §7.4.2 requires purchasing information.",
              "parameter": "OrderItem includes: partID (links to full part specification), quantity, price, orderLineTypeID. Part record includes: name, description, vendor, SKU, manufacturer, manufacturerPN, partCategory, serialNumberRequired, lotNumberRequired. Bulk import matches parts by name to ensure consistency.",
              "verification": "Order items reference valid parts with complete specifications. Bulk import validates against existing parts catalog.",
              "validation": "Purchase order contains sufficient detail for supplier to provide correct product.",
              "categoryName": "Purchasing Controls"
            },
            {
              "description": "The system shall support receiving inspection by tracking received quantities against ordered quantities and recording receiving activities.",
              "rationale": "21 CFR 820.80 requires acceptance activities including receiving acceptance. ISO 13485:2016 §7.4.3 requires verification of purchased product.",
              "parameter": "OrderItem tracks receivedQuantity vs quantity. Receiving creates Trace or Equipment records with RECEIVED barcode history action. Order status auto-advances when all items fully received (REQ-ORD-004). Receiving records user, timestamp, and location.",
              "verification": "Received quantities recorded against each line item. Receiving creates inventory records with full traceability.",
              "validation": "Receiving personnel can verify and record incoming products against the purchase order.",
              "categoryName": "Purchasing Controls"
            },
            {
              "description": "The system shall support evaluation and monitoring of external providers (suppliers) by maintaining vendor performance data through order status tracking and receiving inspection records.",
              "rationale": "AS9100D §8.4.1 requires determining and applying criteria for evaluation, selection, monitoring, and re-evaluation of external providers. ISO 13485:2016 §7.4.1 requires evaluation of suppliers based on their ability to supply conforming product.",
              "parameter": "Orders track vendor identity, order status progression, and receiving outcomes. Order items track ordered vs received quantities (short shipments visible). Vendor parts link to manufacturer data for authorized source verification. Order list view supports filtering by vendor for performance review. Historical order data enables vendor performance analysis.",
              "verification": "Orders record vendor identity. Receiving discrepancies (ordered vs received) are tracked. Order history filterable by vendor.",
              "validation": "Quality team can review vendor order history, delivery performance, and receiving discrepancies.",
              "categoryName": "External Providers"
            }
          ]
        },
        {
          "description": "The system shall provide unique identification for all inventory items throughout their lifecycle using auto-generated barcodes.",
          "rationale": "21 CFR 820.60 requires procedures for identifying product during all stages to prevent mixups. ISO 13485:2016 §7.5.3 requires identification and traceability. 21 CFR 820.65 requires traceability for products intended for surgical implantation or life-supporting/sustaining.",
          "parameter": "Every Location, Box, Trace, and Equipment receives a unique barcode (PREFIX-XXXXXX hex format). Categories: AKL (parts/traces), LOC (locations), BOX (boxes), EQP (equipment). Barcode is generated automatically and immutable once assigned.",
          "verification": "All inventory entities have unique, non-null barcodeID. No duplicate barcode strings exist.",
          "validation": "Any physical item can be identified by scanning its barcode label.",
          "categoryName": "Identification & Traceability",
          "children": [
            {
              "description": "The system shall maintain a complete audit trail of all inventory movements, transformations, and status changes.",
              "rationale": "21 CFR 820.184 requires a Device History Record (DHR) showing dates and personnel for manufacturing activities. ISO 13485:2016 §7.5.9 requires traceability records. Traceability from raw material receipt through final product is essential for recalls and investigations.",
              "parameter": "BarcodeHistory records: CREATED, MOVED, RECEIVED, SPLIT, MERGED, DELETED actions with userID, timestamp, fromID, toID, quantity, serialNumber, lotNumber. Each history record is immutable (insert-only). Chain queries reconstruct full item history.",
              "verification": "Every inventory action creates a history record. History records cannot be modified or deleted. Complete chain from receipt to current state is reconstructable.",
              "validation": "For any inventory item, auditor can trace its complete history from receipt through all movements and transformations.",
              "categoryName": "Identification & Traceability"
            },
            {
              "description": "The system shall support serial number and lot number tracking for parts that require it.",
              "rationale": "21 CFR 820.65 requires traceability by control number (lot/serial). ISO 13485:2016 §7.5.9.1 requires unique identification of each unit or batch of medical device. Enables targeted recalls and failure investigations.",
              "parameter": "Part model includes `serialNumberRequired` and `lotNumberRequired` flags. Trace records include optional `serialNumber` and `lotNumber` fields. Barcode history records include serialNumber and lotNumber for traceability. Parts with serialNumberRequired must have unique serial numbers per trace.",
              "verification": "Parts marked serialNumberRequired enforce serial number on trace creation. Serial/lot numbers recorded in barcode history.",
              "validation": "Auditor can trace a specific serial number or lot number through the complete supply chain within the system.",
              "categoryName": "Identification & Traceability"
            }
          ]
        },
        {
          "description": "The system shall support production planning through task management with defined workflows, scheduling, and time tracking.",
          "rationale": "21 CFR 820.70 requires that production processes are developed, conducted, controlled, and monitored. ISO 13485:2016 §7.5.1 requires control of production and service provision.",
          "parameter": "Task management with Kanban workflow (REQ-PLN-001). Task types include: normal, tracking, critical_path, scheduled. Tasks linked to projects for work breakdown. Time tracking via calendar integration (REQ-PLN-011). Scheduled tasks for recurring operations (REQ-PLN-010).",
          "verification": "Tasks progress through defined workflow stages. Time tracking records are created for work activities.",
          "validation": "Production activities are planned, tracked, and completed through the task system.",
          "categoryName": "Production & Process Controls",
          "children": [
            {
              "description": "The system shall provide controlled manufacturing specifications through released harness designs that are read-only and revision-controlled.",
              "rationale": "21 CFR 820.70(a) requires production processes performed according to approved instructions and SOPs. ISO 13485:2016 §7.5.1(b) requires availability of documented procedures and work instructions.",
              "parameter": "Released harness designs are immutable (REQ-HAR-014). Only released designs are valid for manufacturing. Edits to released designs create new revisions (REQ-HAR-015). Complete revision history available (REQ-SYS-DC-005).",
              "verification": "Released harness cannot be modified through any API endpoint. All edit controls disabled in UI.",
              "validation": "Manufacturing uses only released designs; any required change follows the revision control process.",
              "categoryName": "Production & Process Controls"
            },
            {
              "description": "The system shall support first article inspection and production process verification by tracking initial production runs through the task and inventory system with full traceability.",
              "rationale": "AS9100D §8.5.1.3 requires production process verification activities including first article inspection (FAI) per AS9102 to validate that production processes produce conforming product. FAI is required for new parts, design changes, and process changes.",
              "parameter": "First article inspection tracked as critical_path task type linked to the relevant harness design revision. FAI task references the specific harness revision and part numbers under inspection. Inventory traces for FAI units carry serial/lot numbers (REQ-SYS-IT-003). Task history records FAI completion with user and timestamp. New harness revisions (REQ-HAR-015) trigger need for new FAI activities.",
              "verification": "FAI tasks created for new design revisions. FAI completion recorded with traceability to specific serial/lot numbers.",
              "validation": "For each released design revision, evidence of first article inspection is traceable through the task and inventory system.",
              "categoryName": "Production Process Verification"
            }
          ]
        },
        {
          "description": "The system shall generate and print standardized barcode labels with consistent formatting for all inventory items.",
          "rationale": "21 CFR 820.120 requires labeling activities to be controlled. ISO 13485:2016 §7.5.1(d) requires the use of suitable monitoring and measurement equipment. Labels must be accurate, legible, and traceable to the correct item.",
          "parameter": "ZPL label generation with company branding, item name, description, and quantity. Two standardized sizes: 3\"x1\" and 1.5\"x1\". Preview before printing (REQ-UX-005). Printing to configured Zebra printers (REQ-BAR-006). Labels always generated from current database state to prevent stale labels.",
          "verification": "Generated ZPL contains correct item data. Label prints match preview.",
          "validation": "Printed labels are legible, accurately identify the item, and scan correctly.",
          "categoryName": "Labeling Controls"
        },
        {
          "description": "The system shall maintain a Device History Record (DHR) for all manufactured products by recording the complete history of design, procurement, manufacturing, and testing activities.",
          "rationale": "21 CFR 820.184 requires a DHR including dates of manufacture, quantity, acceptance records, labeling, and primary identification. ISO 13485:2016 §7.5.1(e) requires records that provide evidence of conformity.",
          "parameter": "DHR is the composite of: harness revision history (design), order history (procurement), barcode history (manufacturing movements and transformations), task history (production activities). All records include userID, timestamp, and action type. Records are immutable (insert-only, no updates or deletes).",
          "verification": "All history tables are insert-only. No UPDATE or DELETE operations on history records. Complete DHR reconstructable for any product.",
          "validation": "For any manufactured item, a complete DHR can be assembled from system records spanning design through shipping.",
          "categoryName": "Records & Data Integrity"
        },
        {
          "description": "The system shall maintain a Design History File (DHF) for each wire harness design by recording all design inputs, outputs, reviews, and changes.",
          "rationale": "21 CFR 820.30(j) requires a Design History File (DHF) for each type of device. ISO 13485:2016 §7.3.10 requires design and development files.",
          "parameter": "DHF is the composite of: HarnessRevisionHistory (all snapshots and change records), release state transitions (submit-review, reject, release with notes and user), and revision chain (previousRevisionID links). `GET /:id/history` and `GET /:id/revisions` endpoints provide DHF data.",
          "verification": "Complete design history exists for all released harness designs. History includes all review decisions and rationale.",
          "validation": "Auditor can reconstruct the complete design evolution for any harness from initial creation through current released version.",
          "categoryName": "Records & Data Integrity"
        },
        {
          "description": "The system shall ensure data integrity through authentication, user attribution, and timestamping of all records.",
          "rationale": "21 CFR 820.180 requires records to be maintained to demonstrate conformity and effective operation of the QMS. 21 CFR Part 11 (electronic records) principles require attributable, legible, contemporaneous, original, and accurate (ALCOA) records.",
          "parameter": "All records include `createdAt` and `updatedAt` timestamps (auto-generated by Sequelize). All user-facing actions record `userID` from authenticated session. JWT authentication ensures identity verification. Soft deletion (REQ-SYS-004) prevents data loss. Database backups provide disaster recovery.",
          "verification": "All records contain non-null createdAt, updatedAt. All action records contain non-null userID. No mechanism exists to modify timestamps retroactively.",
          "validation": "Records satisfy ALCOA principles: each record is attributable to a user, legible in the UI, contemporaneously timestamped, stored as original, and accurate to the action performed.",
          "categoryName": "Records & Data Integrity",
          "children": [
            {
              "description": "The system shall provide automated PostgreSQL database backups with change detection, email notifications, and off-site pull.",
              "rationale": "Data loss prevention requires regular, verified backups stored in multiple locations.",
              "parameter": "VPS script (`scripts/backup-db.sh`): daily `pg_dump -Fc` compressed backup. Change detection via `pg_stat_user_tables` hash (skips backup if no changes). Disk usage check (skips if >= 90% full). Email notifications via Gmail SMTP for success/failure. Off-site script (`scripts/pull-backup.sh`): pulls all `.dump` files from VPS via SCP. Successfully pulled files deleted from VPS. Skips already-downloaded files. Email notifications for pull status. VPS cron: daily at 2 AM. Off-site cron: daily at 2:10 AM.",
              "verification": "Backup script creates `.dump` file when data changes. Pull script downloads and removes remote files.",
              "validation": "Database can be restored from a backup file using `pg_restore`.",
              "categoryName": "Development"
            }
          ]
        },
        {
          "description": "The system shall support operational risk identification and mitigation by providing task types that distinguish risk-critical activities and scheduling controls for recurring risk-mitigation tasks.",
          "rationale": "AS9100D §8.1.1 requires planning and management of operational risks that could directly affect product or service realization. Risks must be identified, assessed, and mitigated throughout the product lifecycle.",
          "parameter": "Task `taskTypeEnum` includes `critical_path` for risk-critical activities requiring heightened oversight. Scheduled tasks (REQ-PLN-010) automate recurring risk-mitigation activities (e.g., inspections, calibrations). Project breakdown (REQ-PLN-005) enables risk categorization by work area. Task history (REQ-PLN-008) provides evidence of risk-mitigation execution.",
          "verification": "Critical path tasks are visually distinguished. Scheduled risk-mitigation tasks execute on schedule.",
          "validation": "Operational risks are tracked and mitigated through planned activities in the task system.",
          "categoryName": "Operational Risk Management"
        },
        {
          "description": "The system shall maintain configuration management for wire harness designs by tracking the identity, functional characteristics, and physical characteristics of each design baseline and all changes to it.",
          "rationale": "AS9100D §8.1.2 requires configuration management appropriate to the organization, ensuring product integrity from design through disposal. Configuration baselines must be established, controlled, and auditable.",
          "parameter": "Configuration identity: each harness has a unique part number (auto-generated via `getNextPartNumber()`) and revision letter (A→B→...→Z→AA). Configuration baseline: released harness designs are frozen (REQ-HAR-014). Configuration change control: edits to released designs create new revisions (REQ-HAR-015) with full change history (REQ-SYS-DC-005). Configuration status: releaseState (draft/review/released) visible in list view (REQ-HAR-016).",
          "verification": "Each harness has unique part number and revision. Released configurations are immutable. All configuration changes create revision history records.",
          "validation": "Auditor can identify the exact configuration baseline for any released harness and trace all changes from the original baseline.",
          "categoryName": "Configuration Management",
          "children": [
            {
              "description": "The system shall maintain configuration management for parts by tracking part identity, vendor, manufacturer, and specification attributes.",
              "rationale": "AS9100D §8.1.2 requires configuration identification and control. Parts catalog serves as the configuration baseline for all purchased and manufactured components.",
              "parameter": "Part model includes: name (unique), vendor, SKU, manufacturer, manufacturerPN, partCategory, serial/lot requirements, default UoM, image. Part changes tracked via updatedAt timestamp and soft deletion. Parts linked to inventory traces, order items, and harness elements via partID foreign key.",
              "verification": "Parts have unique names. Vendor parts have manufacturer traceability. Part changes update timestamp.",
              "validation": "Any part used in production can be traced to its complete specification including vendor and manufacturer data.",
              "categoryName": "Configuration Management"
            }
          ]
        },
        {
          "description": "The system shall support product safety by enforcing design review gates, maintaining traceability for safety-critical components, and ensuring manufacturing uses only approved (released) designs.",
          "rationale": "AS9100D §8.1.3 requires organizations to plan, implement, and control processes for assessing and managing product safety risks. Safety-critical products require additional controls throughout the lifecycle.",
          "parameter": "Design review gates (REQ-SYS-DC-004) prevent unapproved designs from reaching production. Released designs are read-only (REQ-HAR-014). Full traceability from part receipt through final assembly (REQ-SYS-IT-002). Serial/lot tracking for safety-critical parts (REQ-SYS-IT-003). Harness validation checks structural integrity before release (REQ-HAR-018).",
          "verification": "No unapproved design can be used for production. All safety-critical parts have serial/lot traceability. Design validation catches structural errors.",
          "validation": "Safety audit confirms only released designs are used in production and all safety-critical parts are fully traceable.",
          "categoryName": "Product Safety"
        },
        {
          "description": "The system shall support counterfeit parts prevention by maintaining manufacturer traceability for all vendor-sourced parts, tracking part provenance from receipt through inventory, and preserving complete procurement records.",
          "rationale": "AS9100D §8.1.4 requires processes for prevention of counterfeit or suspect counterfeit parts and their use. Organizations must ensure parts are procured from authorized sources with full traceability to the original manufacturer.",
          "parameter": "Vendor parts require manufacturer and manufacturer part number (REQ-PRT-002). Parts linked to vendor and SKU for authorized source verification. Order records track vendor, date placed, and receiving details (REQ-ORD-001). Receiving creates barcode history RECEIVED action linking part to order (REQ-SYS-PC-003). Complete chain: manufacturer → vendor → purchase order → receiving → inventory trace with serial/lot.",
          "verification": "No vendor part can be created without manufacturer data. All received parts link to a purchase order. Complete provenance chain is reconstructable.",
          "validation": "For any part in inventory, auditor can trace provenance from manufacturer through vendor, purchase order, receiving event, and current location.",
          "categoryName": "Counterfeit Parts Prevention"
        },
        {
          "description": "The system shall support identification and control of nonconforming product through inventory status management, quarantine via location assignment, and soft deletion for disposition.",
          "rationale": "AS9100D §8.7 requires identification, documentation, segregation, and disposition of nonconforming outputs. 21 CFR 820.90 requires procedures for control of nonconforming product. ISO 13485:2016 §8.3 requires documented procedure for nonconforming product.",
          "parameter": "Nonconforming product identified through inventory system. Quarantine supported via barcode move to designated quarantine location (REQ-BAR-003). Disposition options: rework (move back to production), scrap (delete trace with DELETED history action), or use-as-is (no action). All disposition actions recorded in barcode history with user and timestamp (REQ-SYS-IT-002). Soft deletion preserves records for investigation (REQ-SYS-004).",
          "verification": "Nonconforming items can be moved to quarantine locations. All disposition actions create history records. Scrapped items remain in database (soft delete).",
          "validation": "Auditor can trace any nonconforming product from identification through disposition, including who performed each action.",
          "categoryName": "Nonconforming Product"
        }
      ]
    }
  ]
}